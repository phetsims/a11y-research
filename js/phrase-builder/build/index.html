<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dynamic Phrase Builder</title>
  <style>
    select {
      margin: 0px 5px; /* a bit of width */
    }

    #content {
      margin: 50px
    }
  </style>
</head>
<body>

<div id="content">
  <h3>Dynamic Phrase Manipulator</h3>
  <p>
    This phrase creator is designed to support prototyping dynamic descriptions. To use, first input description
    content in the first text area. Within that area, factor out sections that may have dynamic content (multiple
    options) into variables annotated like "{{templateVariable}}". Each of these (note two curly braces on each side and
    no spaces) will be automatically detected, and a ui created for them to input each possible dynamic option for that
    variable. An example sentence may look like "I like to eat, eat, eat, apples and {{otherFruit}}." In this case, a
    single variable text box will be added, and each option for "otherFruit" can be added on a new line there.
  </p>
  <p>
    As the input sentence and variable options are populated, the output will display the original sentence, but with
    each variable filled in with a select box filled with all the dynamic options filled in for that variable.
  </p>
  <p>
    Refreshing the page will automatically load the most recently autosaved descriptions.
  </p>
  <div id="container"></div>

  <br>
  <br>
  <hr>
  <h3>Save and load</h3>
  <p>save and load under a specific name to get it back later.</p>
  <label>Description Name:</label>
  <input type="text" id="descriptionName"/>

  <button id="save">Save</button>
  <button id="load">Load</button>
</div>
</body>
<script>// Copyright 2013-2020, University of Colorado Boulder

/*
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */

( function() {
  'use strict';

  window.assertions = window.assertions || {};
  window.assertions.assertFunction = window.assertions.assertFunction || function( predicate, message ) {
    if ( !predicate ) {

      // Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.
      if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {
        try { throw new Error(); }
        catch( e ) { message = message + ', stack=\n' + e.stack; }
      }

      const logMessage = message ? 'Assertion failed: ' + message : 'Assertion failed';
      console && console.log && console.log( logMessage );
      if ( window.phet && phet.chipper && phet.chipper.queryParameters && phet.chipper.queryParameters.debugger ) {
        debugger; // eslint-disable-line no-debugger
      }
      throw new Error( logMessage );
    }
  };

  window.assert = window.assert || null;
  window.assertSlow = window.assertSlow || null;

  window.assertions.enableAssert = function() {
    window.assert = window.assertions.assertFunction;
    window.console && window.console.log && window.console.log( 'enabling assert' );
  };
  window.assertions.disableAssert = function() {
    window.assert = null;
    window.console && window.console.log && window.console.log( 'disabling assert' );
  };

  window.assertions.enableAssertSlow = function() {
    window.assertSlow = window.assertions.assertFunction;
    window.console && window.console.log && window.console.log( 'enabling assertSlow' );
  };
  window.assertions.disableAssertSlow = function() {
    window.assertSlow = null;
    window.console && window.console.log && window.console.log( 'disabling assertSlow' );
  };
} )();
</script>

<script>/**
 * @license
 * Lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE
 */
;(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function i(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););
  return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function c(n,t){return!(null==n||!n.length)&&-1<d(n,t,0)}function a(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];
  return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function _(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function g(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function d(n,t,r){if(t===t)n:{
  --r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=g(n,b,r);return n}function y(n,t,r,e){--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function b(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:P}function j(n){return function(t){return null==t?F:t[n]}}function w(n){return function(t){return null==n?F:n[t]}}function m(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;
  return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function O(n,t){return l(t,function(t){return[t,n[t]]})}function S(n){return function(t){return n(t)}}function I(n,t){return l(t,function(t){return n[t]})}function R(n,t){return n.has(t)}function z(n,t){for(var r=-1,e=n.length;++r<e&&-1<d(t,n[r],0););return r}function W(n,t){for(var r=n.length;r--&&-1<d(t,n[r],0););return r}function B(n){
  return"\\"+Tn[n]}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function U(n,t){return function(r){return n(t(r))}}function C(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function T(n){if(Bn.test(n)){
  for(var t=zn.lastIndex=0;zn.test(n);)++t;n=t}else n=tt(n);return n}function $(n){return Bn.test(n)?n.match(zn)||[]:n.split("")}var F,N=1/0,P=NaN,Z=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],q=/\b__p\+='';/g,V=/\b(__p\+=)''\+/g,K=/(__e\(.*?\)|\b__t\))\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,H=/[&<>"']/g,J=RegExp(G.source),Y=RegExp(H.source),Q=/<%-([\s\S]+?)%>/g,X=/<%([\s\S]+?)%>/g,nn=/<%=([\s\S]+?)%>/g,tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,rn=/^\w*$/,en=/^\./,un=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,on=/[\\^$.*+?()[\]{}|]/g,fn=RegExp(on.source),cn=/^\s+|\s+$/g,an=/^\s+/,ln=/\s+$/,sn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,hn=/\{\n\/\* \[wrapped with (.+)\] \*/,pn=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,vn=/\\(\\)?/g,gn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dn=/\w*$/,yn=/^[-+]0x[0-9a-f]+$/i,bn=/^0b[01]+$/i,xn=/^\[object .+?Constructor\]$/,jn=/^0o[0-7]+$/i,wn=/^(?:0|[1-9]\d*)$/,mn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,An=/($^)/,kn=/['\n\r\u2028\u2029\\]/g,En="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",On="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+En,Sn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",In=RegExp("['\u2019]","g"),Rn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),zn=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+Sn+En,"g"),Wn=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+",On].join("|"),"g"),Bn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),Ln=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Un="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Cn={};
  Cn["[object Float32Array]"]=Cn["[object Float64Array]"]=Cn["[object Int8Array]"]=Cn["[object Int16Array]"]=Cn["[object Int32Array]"]=Cn["[object Uint8Array]"]=Cn["[object Uint8ClampedArray]"]=Cn["[object Uint16Array]"]=Cn["[object Uint32Array]"]=true,Cn["[object Arguments]"]=Cn["[object Array]"]=Cn["[object ArrayBuffer]"]=Cn["[object Boolean]"]=Cn["[object DataView]"]=Cn["[object Date]"]=Cn["[object Error]"]=Cn["[object Function]"]=Cn["[object Map]"]=Cn["[object Number]"]=Cn["[object Object]"]=Cn["[object RegExp]"]=Cn["[object Set]"]=Cn["[object String]"]=Cn["[object WeakMap]"]=false;
  var Dn={};Dn["[object Arguments]"]=Dn["[object Array]"]=Dn["[object ArrayBuffer]"]=Dn["[object DataView]"]=Dn["[object Boolean]"]=Dn["[object Date]"]=Dn["[object Float32Array]"]=Dn["[object Float64Array]"]=Dn["[object Int8Array]"]=Dn["[object Int16Array]"]=Dn["[object Int32Array]"]=Dn["[object Map]"]=Dn["[object Number]"]=Dn["[object Object]"]=Dn["[object RegExp]"]=Dn["[object Set]"]=Dn["[object String]"]=Dn["[object Symbol]"]=Dn["[object Uint8Array]"]=Dn["[object Uint8ClampedArray]"]=Dn["[object Uint16Array]"]=Dn["[object Uint32Array]"]=true,
    Dn["[object Error]"]=Dn["[object Function]"]=Dn["[object WeakMap]"]=false;var Mn,Tn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},$n=parseFloat,Fn=parseInt,Nn=typeof global=="object"&&global&&global.Object===Object&&global,Pn=typeof self=="object"&&self&&self.Object===Object&&self,Zn=Nn||Pn||Function("return this")(),qn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Vn=qn&&typeof module=="object"&&module&&!module.nodeType&&module,Kn=Vn&&Vn.exports===qn,Gn=Kn&&Nn.process;
  n:{try{Mn=Gn&&Gn.binding&&Gn.binding("util");break n}catch(n){}Mn=void 0}var Hn=Mn&&Mn.isArrayBuffer,Jn=Mn&&Mn.isDate,Yn=Mn&&Mn.isMap,Qn=Mn&&Mn.isRegExp,Xn=Mn&&Mn.isSet,nt=Mn&&Mn.isTypedArray,tt=j("length"),rt=w({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I",
    "\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C",
    "\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i",
    "\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S",
    "\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe",
    "\u0149":"'n","\u017f":"s"}),et=w({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),ut=w({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),it=function w(En){function On(n){if(xu(n)&&!af(n)&&!(n instanceof Mn)){if(n instanceof zn)return n;if(ci.call(n,"__wrapped__"))return Pe(n)}return new zn(n)}function Sn(){}function zn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=F}function Mn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,
    this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Pn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function qn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Pn;++t<r;)this.add(n[t])}function Vn(n){
    this.size=(this.__data__=new Nn(n)).size}function Gn(n,t){var r,e=af(n),u=!e&&cf(n),i=!e&&!u&&sf(n),o=!e&&!u&&!i&&gf(n),u=(e=e||u||i||o)?E(n.length,ri):[],f=u.length;for(r in n)!t&&!ci.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Re(r,f))||u.push(r);return u}function tt(n){var t=n.length;return t?n[cr(0,t-1)]:F}function ot(n,t){return Te(Mr(n),gt(t,0,n.length))}function ft(n){return Te(Mr(n))}function ct(n,t,r){(r===F||hu(n[t],r))&&(r!==F||t in n)||_t(n,t,r);
  }function at(n,t,r){var e=n[t];ci.call(n,t)&&hu(e,r)&&(r!==F||t in n)||_t(n,t,r)}function lt(n,t){for(var r=n.length;r--;)if(hu(n[r][0],t))return r;return-1}function st(n,t,r,e){return oo(n,function(n,u,i){t(e,n,r(n),i)}),e}function ht(n,t){return n&&Tr(t,Lu(t),n)}function pt(n,t){return n&&Tr(t,Uu(t),n)}function _t(n,t,r){"__proto__"==t&&Ei?Ei(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function vt(n,t){for(var r=-1,e=t.length,u=Hu(e),i=null==n;++r<e;)u[r]=i?F:Wu(n,t[r]);return u;
  }function gt(n,t,r){return n===n&&(r!==F&&(n=n<=r?n:r),t!==F&&(n=n>=t?n:t)),n}function dt(n,t,r,e,i,o){var f,c=1&t,a=2&t,l=4&t;if(r&&(f=i?r(n,e,i,o):r(n)),f!==F)return f;if(!bu(n))return n;if(e=af(n)){if(f=Ee(n),!c)return Mr(n,f)}else{var s=yo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(sf(n))return Wr(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Oe(n),!c)return a?Fr(n,pt(f,n)):$r(n,ht(f,n))}else{if(!Dn[s])return i?n:{};f=Se(n,s,dt,c)}}if(o||(o=new Vn),
      i=o.get(n))return i;o.set(n,f);var a=l?a?ye:de:a?Uu:Lu,p=e?F:a(n);return u(p||n,function(e,u){p&&(u=e,e=n[u]),at(f,u,dt(e,t,r,u,n,o))}),f}function yt(n){var t=Lu(n);return function(r){return bt(r,n,t)}}function bt(n,t,r){var e=r.length;if(null==n)return!e;for(n=ni(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===F&&!(u in n)||!i(o))return false}return true}function xt(n,t,r){if(typeof n!="function")throw new ei("Expected a function");return jo(function(){n.apply(F,r)},t)}function jt(n,t,r,e){var u=-1,i=c,o=true,f=n.length,s=[],h=t.length;
    if(!f)return s;r&&(t=l(t,S(r))),e?(i=a,o=false):200<=t.length&&(i=R,o=false,t=new qn(t));n:for(;++u<f;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function wt(n,t){var r=true;return oo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function mt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===F?o===o&&!Au(o):r(o,f)))var f=o,c=i}return c}function At(n,t){var r=[];return oo(n,function(n,e,u){
    t(n,e,u)&&r.push(n)}),r}function kt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ie),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?kt(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function Et(n,t){return n&&co(n,t,Lu)}function Ot(n,t){return n&&ao(n,t,Lu)}function St(n,t){return f(t,function(t){return gu(n[t])})}function It(n,t){t=Rr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[$e(t[r++])];return r&&r==e?n:F}function Rt(n,t,r){return t=t(n),af(n)?t:s(t,r(n))}function zt(n){if(null==n)n=n===F?"[object Undefined]":"[object Null]";else if(ki&&ki in ni(n)){
    var t=ci.call(n,ki),r=n[ki];try{n[ki]=F;var e=true}catch(n){}var u=si.call(n);e&&(t?n[ki]=r:delete n[ki]),n=u}else n=si.call(n);return n}function Wt(n,t){return n>t}function Bt(n,t){return null!=n&&ci.call(n,t)}function Lt(n,t){return null!=n&&t in ni(n)}function Ut(n,t,r){for(var e=r?a:c,u=n[0].length,i=n.length,o=i,f=Hu(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,S(t))),s=Mi(p.length,s),f[o]=!r&&(t||120<=u&&120<=p.length)?new qn(o&&p):F}var p=n[0],_=-1,v=f[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;
    if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(n[o],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ct(n,t,r){var e={};return Et(n,function(n,u,i){t(e,r(n),u,i)}),e}function Dt(n,t,e){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),t=null==n?n:n[$e(Ge(t))],null==t?F:r(t,n,e)}function Mt(n){return xu(n)&&"[object Arguments]"==zt(n)}function Tt(n){return xu(n)&&"[object ArrayBuffer]"==zt(n)}function $t(n){return xu(n)&&"[object Date]"==zt(n)}function Ft(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!xu(n)&&!xu(t))t=n!==n&&t!==t;else n:{
    var i=af(n),o=af(t),f=i?"[object Array]":yo(n),c=o?"[object Array]":yo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&sf(n)){if(!sf(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Vn),t=i||gf(n)?_e(n,t,r,e,Ft,u):ve(n,t,f,r,e,Ft,u);else{if(!(1&r)&&(i=a&&ci.call(n,"__wrapped__"),f=o&&ci.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Vn),t=Ft(n,t,r,e,u);break n}if(c)t:if(u||(u=new Vn),
        i=1&r,f=de(n),o=f.length,c=de(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:ci.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===F?h!==p&&!Ft(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l)}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),
      u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Nt(n){return xu(n)&&"[object Map]"==yo(n)}function Pt(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ni(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in n))return false}else{if(f=new Vn,e)var s=e(a,l,c,n,t,f);if(s===F?!Ft(l,a,3,e,f):!s)return false}}return true}function Zt(n){return!(!bu(n)||li&&li in n)&&(gu(n)?_i:xn).test(Fe(n))}function qt(n){
    return xu(n)&&"[object RegExp]"==zt(n)}function Vt(n){return xu(n)&&"[object Set]"==yo(n)}function Kt(n){return xu(n)&&yu(n.length)&&!!Cn[zt(n)]}function Gt(n){return typeof n=="function"?n:null==n?Nu:typeof n=="object"?af(n)?Xt(n[0],n[1]):Qt(n):Vu(n)}function Ht(n){if(!Le(n))return Ci(n);var t,r=[];for(t in ni(n))ci.call(n,t)&&"constructor"!=t&&r.push(t);return r}function Jt(n,t){return n<t}function Yt(n,t){var r=-1,e=pu(n)?Hu(n.length):[];return oo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Qt(n){
    var t=me(n);return 1==t.length&&t[0][2]?Ue(t[0][0],t[0][1]):function(r){return r===n||Pt(r,n,t)}}function Xt(n,t){return We(n)&&t===t&&!bu(t)?Ue($e(n),t):function(r){var e=Wu(r,n);return e===F&&e===t?Bu(r,n):Ft(t,e,3)}}function nr(n,t,r,e,u){n!==t&&co(t,function(i,o){if(bu(i)){u||(u=new Vn);var f=u,c=n[o],a=t[o],l=f.get(a);if(l)ct(n,o,l);else{var l=e?e(c,a,o+"",n,t,f):F,s=l===F;if(s){var h=af(a),p=!h&&sf(a),_=!h&&!p&&gf(a),l=a;h||p||_?af(c)?l=c:_u(c)?l=Mr(c):p?(s=false,l=Wr(a,true)):_?(s=false,l=Lr(a,true)):l=[]:wu(a)||cf(a)?(l=c,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        cf(c)?l=Ru(c):(!bu(c)||r&&gu(c))&&(l=Oe(a))):s=false}s&&(f.set(a,l),nr(l,a,r,e,f),f.delete(a)),ct(n,o,l)}}else f=e?e(n[o],i,o+"",n,t,u):F,f===F&&(f=i),ct(n,o,f)},Uu)}function tr(n,t){var r=n.length;if(r)return t+=0>t?r:0,Re(t,r)?n[t]:F}function rr(n,t,r){var e=-1;return t=l(t.length?t:[Nu],S(je())),n=Yt(n,function(n){return{a:l(t,function(t){return t(n)}),b:++e,c:n}}),A(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Ur(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);
    break n}}e=n.b-t.b}return e})}function er(n,t){return ur(n,t,function(t,r){return Bu(n,r)})}function ur(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=It(n,o);r(f,o)&&pr(i,Rr(o,n),f)}return i}function ir(n){return function(t){return It(t,n)}}function or(n,t,r,e){var u=e?y:d,i=-1,o=t.length,f=n;for(n===t&&(t=Mr(t)),r&&(f=l(n,S(r)));++i<o;)for(var c=0,a=t[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==n&&wi.call(f,c,1),wi.call(n,c,1);return n}function fr(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];
    if(r==e||u!==i){var i=u;Re(u)?wi.call(n,u,1):mr(n,u)}}}function cr(n,t){return n+zi(Fi()*(t-n+1))}function ar(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=zi(t/2))&&(n+=n);while(t);return r}function lr(n,t){return wo(Ce(n,t,Nu),n+"")}function sr(n){return tt(Du(n))}function hr(n,t){var r=Du(n);return Te(r,gt(t,0,r.length))}function pr(n,t,r,e){if(!bu(n))return n;t=Rr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=$e(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;
    a===F&&(a=bu(l)?l:Re(t[u+1])?[]:{})}at(f,c,a),f=f[c]}return n}function _r(n){return Te(Du(n))}function vr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Hu(u);++e<u;)r[e]=n[e+t];return r}function gr(n,t){var r;return oo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function dr(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!Au(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return yr(n,t,Nu,r);
  }function yr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=Au(t),a=t===F;u<i;){var l=zi((u+i)/2),s=r(n[l]),h=s!==F,p=null===s,_=s===s,v=Au(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Mi(i,4294967294)}function br(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!hu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(n){return typeof n=="number"?n:Au(n)?P:+n}function jr(n){if(typeof n=="string")return n;
    if(af(n))return l(n,jr)+"";if(Au(n))return uo?uo.call(n):"";var t=n+"";return"0"==t&&1/n==-N?"-0":t}function wr(n,t,r){var e=-1,u=c,i=n.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=t?null:po(n))return D(u);o=false,u=R,l=new qn}else l=t?[]:f;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(n,t){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),
  null==n||delete n[$e(Ge(t))]}function Ar(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?vr(n,e?0:i,e?i+1:u):vr(n,e?i+1:0,e?u:i)}function kr(n,t){var r=n;return r instanceof Mn&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function Er(n,t,r){var e=n.length;if(2>e)return e?wr(n[0]):[];for(var u=-1,i=Hu(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=jt(i[u]||o,n[f],t,r));return wr(kt(i,1),t,r)}function Or(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:F);
    return o}function Sr(n){return _u(n)?n:[]}function Ir(n){return typeof n=="function"?n:Nu}function Rr(n,t){return af(n)?n:We(n,t)?[n]:mo(zu(n))}function zr(n,t,r){var e=n.length;return r=r===F?e:r,!t&&r>=e?n:vr(n,t,r)}function Wr(n,t){if(t)return n.slice();var r=n.length,r=yi?yi(r):new n.constructor(r);return n.copy(r),r}function Br(n){var t=new n.constructor(n.byteLength);return new di(t).set(new di(n)),t}function Lr(n,t){return new n.constructor(t?Br(n.buffer):n.buffer,n.byteOffset,n.length)}function Ur(n,t){
    if(n!==t){var r=n!==F,e=null===n,u=n===n,i=Au(n),o=t!==F,f=null===t,c=t===t,a=Au(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cr(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Di(i-o,0),l=Hu(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Dr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Di(i-f,0),s=Hu(l+a);
    for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Mr(n,t){var r=-1,e=n.length;for(t||(t=Hu(e));++r<e;)t[r]=n[r];return t}function Tr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):F;c===F&&(c=n[f]),u?_t(r,f,c):at(r,f,c)}return r}function $r(n,t){return Tr(n,vo(n),t)}function Fr(n,t){return Tr(n,go(n),t)}function Nr(n,t){return function(r,u){var i=af(r)?e:st,o=t?t():{};return i(r,n,je(u,2),o);
  }}function Pr(n){return lr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<n.length&&typeof i=="function"?(u--,i):F;for(o&&ze(r[0],r[1],o)&&(i=3>u?F:i,u=1),t=ni(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Zr(n,t){return function(r,e){if(null==r)return r;if(!pu(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ni(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function qr(n){return function(t,r,e){var u=-1,i=ni(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
  }return t}}function Vr(n,t,r){function e(){return(this&&this!==Zn&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Hr(n);return e}function Kr(n){return function(t){t=zu(t);var r=Bn.test(t)?$(t):F,e=r?r[0]:t.charAt(0);return t=r?zr(r,1).join(""):t.slice(1),e[n]()+t}}function Gr(n){return function(t){return h($u(Tu(t).replace(In,"")),n,"")}}function Hr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
    return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=io(n.prototype),t=n.apply(r,t);return bu(t)?t:r}}function Jr(n,t,e){function u(){for(var o=arguments.length,f=Hu(o),c=o,a=xe(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?fe(n,t,Xr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Zn&&this instanceof u?i:n,this,f);
  }var i=Hr(n);return u}function Yr(n){return function(t,r,e){var u=ni(t);if(!pu(t)){var i=je(r,3);t=Lu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:F}}function Qr(n){return ge(function(t){var r=t.length,e=r,u=zn.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ei("Expected a function");if(u&&!o&&"wrapper"==be(i))var o=new zn([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=be(i),f="wrapper"==u?_o(i):F,o=f&&Be(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[be(f[0])].apply(o,f[3]):1==i.length&&Be(i)?o[u]():o.thru(i);
    return function(){var n=arguments,e=n[0];if(o&&1==n.length&&af(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Xr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Hu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=xe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Cr(y,e,u,_)),i&&(y=Dr(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),fe(n,t,Xr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Mi(f.length,x),m=Mr(y);w--;){
    var A=f[w];y[w]=Re(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Zn&&this instanceof l&&(b=g||Hr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?F:Hr(n);return l}function ne(n,t){return function(r,e){return Ct(r,n,t(e))}}function te(n,t){return function(r,e){var u;if(r===F&&e===F)return t;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r=="string"||typeof e=="string"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=n(r,e)}return u}}function re(n){return ge(function(t){
    return t=l(t,S(je())),lr(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ee(n,t){t=t===F?" ":jr(t);var r=t.length;return 2>r?r?ar(t,n):t:(r=ar(t,Ri(n/T(t))),Bn.test(t)?zr($(r),0,n).join(""):r.slice(0,n))}function ue(n,t,e,u){function i(){for(var t=-1,c=arguments.length,a=-1,l=u.length,s=Hu(l+c),h=this&&this!==Zn&&this instanceof i?f:n;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++t];return r(h,o?e:this,s)}var o=1&t,f=Hr(n);return i}function ie(n){return function(t,r,e){
    e&&typeof e!="number"&&ze(t,r,e)&&(r=e=F),t=Eu(t),r===F?(r=t,t=0):r=Eu(r),e=e===F?t<r?1:-1:Eu(e);var u=-1;r=Di(Ri((r-t)/(e||1)),0);for(var i=Hu(r);r--;)i[n?r:++u]=t,t+=e;return i}}function oe(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Iu(t),r=Iu(r)),n(t,r)}}function fe(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(F,u),Be(n)&&xo(r,u),r.placeholder=e,De(r,n,t)}function ce(n){
    var t=Xu[n];return function(n,r){if(n=Iu(n),r=null==r?0:Mi(Ou(r),292)){var e=(zu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(zu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ae(n){return function(t){var r=yo(t);return"[object Map]"==r?L(t):"[object Set]"==r?M(t):O(t,n(t))}}function le(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ei("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=F),o=o===F?o:Di(Ou(o),0),f=f===F?f:Ou(f),a-=u?u.length:0,64&t){
    var l=e,s=u;e=u=F}var h=c?F:_o(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Cr(e,r,h[4]):r,i[4]=e?C(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Dr(e,r,h[6]):r,i[6]=e?C(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Mi(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
    r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===F?c?0:n.length:Di(i[9]-a,0),!f&&24&t&&(t&=-25),De((h?lo:xo)(t&&1!=t?8==t||16==t?Jr(n,t,f):32!=t&&33!=t||u.length?Xr.apply(F,i):ue(n,t,r,e):Vr(n,t,r),i),n,t)}function se(n,t,r,e){return n===F||hu(n,ii[r])&&!ci.call(e,r)?t:n}function he(n,t,r,e,u,i){return bu(n)&&bu(t)&&(i.set(t,n),nr(n,t,F,he,i),i.delete(t)),n}function pe(n){return wu(n)?F:n}function _e(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;var c=-1,a=true,l=2&r?new qn:F;
    for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],h=t[c];if(e)var p=o?e(h,s,c,t,n,i):e(s,h,c,n,t,i);if(p!==F){if(p)continue;a=false;break}if(l){if(!_(t,function(n,t){if(!R(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==h&&!u(s,h,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function ve(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":if(n.byteLength!=t.byteLength||!i(new di(n),new di(t)))break;
    return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return hu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=L;case"[object Set]":if(f||(f=D),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=_e(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(eo)return eo.call(n)==eo.call(t)}return false}function ge(n){return wo(Ce(n,F,Ve),n+"")}function de(n){
    return Rt(n,Lu,vo)}function ye(n){return Rt(n,Uu,go)}function be(n){for(var t=n.name+"",r=Ji[t],e=ci.call(Ji,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function xe(n){return(ci.call(On,"placeholder")?On:n).placeholder}function je(){var n=On.iteratee||Pu,n=n===Pu?Gt:n;return arguments.length?n(arguments[0],arguments[1]):n}function we(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
  }function me(n){for(var t=Lu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!bu(u)]}return t}function Ae(n,t){var r=null==n?F:n[t];return Zt(r)?r:F}function ke(n,t,r){t=Rr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=$e(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&yu(u)&&Re(o,u)&&(af(n)||cf(n)))}function Ee(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ci.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Oe(n){
    return typeof n.constructor!="function"||Le(n)?{}:io(bi(n))}function Se(r,e,u,i){var o=r.constructor;switch(e){case"[object ArrayBuffer]":return Br(r);case"[object Boolean]":case"[object Date]":return new o(+r);case"[object DataView]":return e=i?Br(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
    case"[object Uint16Array]":case"[object Uint32Array]":return Lr(r,i);case"[object Map]":return e=i?u(L(r),1):L(r),h(e,n,new r.constructor);case"[object Number]":case"[object String]":return new o(r);case"[object RegExp]":return e=new r.constructor(r.source,dn.exec(r)),e.lastIndex=r.lastIndex,e;case"[object Set]":return e=i?u(D(r),1):D(r),h(e,t,new r.constructor);case"[object Symbol]":return eo?ni(eo.call(r)):{}}}function Ie(n){return af(n)||cf(n)||!!(mi&&n&&n[mi])}function Re(n,t){return t=null==t?9007199254740991:t,
  !!t&&(typeof n=="number"||wn.test(n))&&-1<n&&0==n%1&&n<t}function ze(n,t,r){if(!bu(r))return false;var e=typeof t;return!!("number"==e?pu(r)&&Re(t,r.length):"string"==e&&t in r)&&hu(r[t],n)}function We(n,t){if(af(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!Au(n))||(rn.test(n)||!tn.test(n)||null!=t&&n in ni(t))}function Be(n){var t=be(n),r=On[t];return typeof r=="function"&&t in Mn.prototype&&(n===r||(t=_o(r),!!t&&n===t[0]))}function Le(n){var t=n&&n.constructor;
    return n===(typeof t=="function"&&t.prototype||ii)}function Ue(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==F||n in ni(r)))}}function Ce(n,t,e){return t=Di(t===F?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Di(u.length-t,0),f=Hu(o);++i<o;)f[i]=u[t+i];for(i=-1,o=Hu(t+1);++i<t;)o[i]=u[i];return o[t]=e(f),r(n,this,o)}}function De(n,t,r){var e=t+"";t=wo;var u,i=Ne;return u=(u=e.match(hn))?u[1].split(pn):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),
    e=e.replace(sn,"{\n/* [wrapped with "+r+"] */\n")),t(n,e)}function Me(n){var t=0,r=0;return function(){var e=Ti(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(F,arguments)}}function Te(n,t){var r=-1,e=n.length,u=e-1;for(t=t===F?e:t;++r<t;){var e=cr(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function $e(n){if(typeof n=="string"||Au(n))return n;var t=n+"";return"0"==t&&1/n==-N?"-0":t}function Fe(n){if(null!=n){try{return fi.call(n)}catch(n){}return n+""}return"";
  }function Ne(n,t){return u(Z,function(r){var e="_."+r[0];t&r[1]&&!c(n,e)&&n.push(e)}),n.sort()}function Pe(n){if(n instanceof Mn)return n.clone();var t=new zn(n.__wrapped__,n.__chain__);return t.__actions__=Mr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ze(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),g(n,je(t,3),r)):-1}function qe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==F&&(u=Ou(r),u=0>r?Di(e+u,0):Mi(u,e-1)),
    g(n,je(t,3),u,true)}function Ve(n){return(null==n?0:n.length)?kt(n,1):[]}function Ke(n){return n&&n.length?n[0]:F}function Ge(n){var t=null==n?0:n.length;return t?n[t-1]:F}function He(n,t){return n&&n.length&&t&&t.length?or(n,t):n}function Je(n){return null==n?n:Ni.call(n)}function Ye(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(_u(n))return t=Di(n.length,t),true}),E(t,function(t){return l(n,j(t))})}function Qe(n,t){if(!n||!n.length)return[];var e=Ye(n);return null==t?e:l(e,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  return r(t,F,n)})}function Xe(n){return n=On(n),n.__chain__=true,n}function nu(n,t){return t(n)}function tu(){return this}function ru(n,t){return(af(n)?u:oo)(n,je(t,3))}function eu(n,t){return(af(n)?i:fo)(n,je(t,3))}function uu(n,t){return(af(n)?l:Yt)(n,je(t,3))}function iu(n,t,r){return t=r?F:t,t=n&&null==t?n.length:t,le(n,128,F,F,F,F,t)}function ou(n,t){var r;if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=F),
    r}}function fu(n,t,r){return t=r?F:t,n=le(n,8,F,F,F,F,F,t),n.placeholder=fu.placeholder,n}function cu(n,t,r){return t=r?F:t,n=le(n,16,F,F,F,F,F,t),n.placeholder=cu.placeholder,n}function au(n,t,r){function e(t){var r=c,e=a;return c=a=F,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===F||r>=t||0>r||g&&n>=l}function i(){var n=Jo();if(u(n))return o(n);var r,e=jo;r=n-_,n=t-(n-p),r=g?Mi(n,l-r):n,h=e(i,r)}function o(n){return h=F,d&&c?e(n):(c=a=F,s)}function f(){var n=Jo(),r=u(n);if(c=arguments,
      a=this,p=n,r){if(h===F)return _=n=p,h=jo(i,t),v?e(n):s;if(g)return h=jo(i,t),e(p)}return h===F&&(h=jo(i,t)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ei("Expected a function");return t=Iu(t)||0,bu(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Di(Iu(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==F&&ho(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Jo())},f}function lu(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ei("Expected a function");return r.cache=new(lu.Cache||Pn),r}function su(n){if(typeof n!="function")throw new ei("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function hu(n,t){return n===t||n!==n&&t!==t}function pu(n){return null!=n&&yu(n.length)&&!gu(n);
  }function _u(n){return xu(n)&&pu(n)}function vu(n){if(!xu(n))return false;var t=zt(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!wu(n)}function gu(n){return!!bu(n)&&(n=zt(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function du(n){return typeof n=="number"&&n==Ou(n)}function yu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function bu(n){var t=typeof n;return null!=n&&("object"==t||"function"==t);
  }function xu(n){return null!=n&&typeof n=="object"}function ju(n){return typeof n=="number"||xu(n)&&"[object Number]"==zt(n)}function wu(n){return!(!xu(n)||"[object Object]"!=zt(n))&&(n=bi(n),null===n||(n=ci.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&fi.call(n)==hi))}function mu(n){return typeof n=="string"||!af(n)&&xu(n)&&"[object String]"==zt(n)}function Au(n){return typeof n=="symbol"||xu(n)&&"[object Symbol]"==zt(n)}function ku(n){if(!n)return[];if(pu(n))return mu(n)?$(n):Mr(n);
    if(Ai&&n[Ai]){n=n[Ai]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=yo(n),("[object Map]"==t?L:"[object Set]"==t?D:Du)(n)}function Eu(n){return n?(n=Iu(n),n===N||n===-N?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Ou(n){n=Eu(n);var t=n%1;return n===n?t?n-t:n:0}function Su(n){return n?gt(Ou(n),0,4294967295):0}function Iu(n){if(typeof n=="number")return n;if(Au(n))return P;if(bu(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=bu(n)?n+"":n),typeof n!="string")return 0===n?n:+n;
    n=n.replace(cn,"");var t=bn.test(n);return t||jn.test(n)?Fn(n.slice(2),t?2:8):yn.test(n)?P:+n}function Ru(n){return Tr(n,Uu(n))}function zu(n){return null==n?"":jr(n)}function Wu(n,t,r){return n=null==n?F:It(n,t),n===F?r:n}function Bu(n,t){return null!=n&&ke(n,t,Lt)}function Lu(n){return pu(n)?Gn(n):Ht(n)}function Uu(n){if(pu(n))n=Gn(n,true);else if(bu(n)){var t,r=Le(n),e=[];for(t in n)("constructor"!=t||!r&&ci.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in ni(n))t.push(r);n=t}return n}function Cu(n,t){
    if(null==n)return{};var r=l(ye(n),function(n){return[n]});return t=je(t),ur(n,r,function(n,r){return t(n,r[0])})}function Du(n){return null==n?[]:I(n,Lu(n))}function Mu(n){return Nf(zu(n).toLowerCase())}function Tu(n){return(n=zu(n))&&n.replace(mn,rt).replace(Rn,"")}function $u(n,t,r){return n=zu(n),t=r?F:t,t===F?Ln.test(n)?n.match(Wn)||[]:n.match(_n)||[]:n.match(t)||[]}function Fu(n){return function(){return n}}function Nu(n){return n}function Pu(n){return Gt(typeof n=="function"?n:dt(n,1))}function Zu(n,t,r){
    var e=Lu(t),i=St(t,e);null!=r||bu(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=St(t,Lu(t)));var o=!(bu(r)&&"chain"in r&&!r.chain),f=gu(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Mr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function qu(){}function Vu(n){return We(n)?j($e(n)):ir(n)}function Ku(){return[]}function Gu(){
    return false}En=null==En?Zn:it.defaults(Zn.Object(),En,it.pick(Zn,Un));var Hu=En.Array,Ju=En.Date,Yu=En.Error,Qu=En.Function,Xu=En.Math,ni=En.Object,ti=En.RegExp,ri=En.String,ei=En.TypeError,ui=Hu.prototype,ii=ni.prototype,oi=En["__core-js_shared__"],fi=Qu.prototype.toString,ci=ii.hasOwnProperty,ai=0,li=function(){var n=/[^.]+$/.exec(oi&&oi.keys&&oi.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),si=ii.toString,hi=fi.call(ni),pi=Zn._,_i=ti("^"+fi.call(ci).replace(on,"\\{{PRELOAD_SCRIPTS}}").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),vi=Kn?En.Buffer:F,gi=En.Symbol,di=En.Uint8Array,yi=vi?vi.f:F,bi=U(ni.getPrototypeOf,ni),xi=ni.create,ji=ii.propertyIsEnumerable,wi=ui.splice,mi=gi?gi.isConcatSpreadable:F,Ai=gi?gi.iterator:F,ki=gi?gi.toStringTag:F,Ei=function(){
    try{var n=Ae(ni,"defineProperty");return n({},"",{}),n}catch(n){}}(),Oi=En.clearTimeout!==Zn.clearTimeout&&En.clearTimeout,Si=Ju&&Ju.now!==Zn.Date.now&&Ju.now,Ii=En.setTimeout!==Zn.setTimeout&&En.setTimeout,Ri=Xu.ceil,zi=Xu.floor,Wi=ni.getOwnPropertySymbols,Bi=vi?vi.isBuffer:F,Li=En.isFinite,Ui=ui.join,Ci=U(ni.keys,ni),Di=Xu.max,Mi=Xu.min,Ti=Ju.now,$i=En.parseInt,Fi=Xu.random,Ni=ui.reverse,Pi=Ae(En,"DataView"),Zi=Ae(En,"Map"),qi=Ae(En,"Promise"),Vi=Ae(En,"Set"),Ki=Ae(En,"WeakMap"),Gi=Ae(ni,"create"),Hi=Ki&&new Ki,Ji={},Yi=Fe(Pi),Qi=Fe(Zi),Xi=Fe(qi),no=Fe(Vi),to=Fe(Ki),ro=gi?gi.prototype:F,eo=ro?ro.valueOf:F,uo=ro?ro.toString:F,io=function(){
    function n(){}return function(t){return bu(t)?xi?xi(t):(n.prototype=t,t=new n,n.prototype=F,t):{}}}();On.templateSettings={escape:Q,evaluate:X,interpolate:nn,variable:"",imports:{_:On}},On.prototype=Sn.prototype,On.prototype.constructor=On,zn.prototype=io(Sn.prototype),zn.prototype.constructor=zn,Mn.prototype=io(Sn.prototype),Mn.prototype.constructor=Mn,Tn.prototype.clear=function(){this.__data__=Gi?Gi(null):{},this.size=0},Tn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
    this.size-=n?1:0,n},Tn.prototype.get=function(n){var t=this.__data__;return Gi?(n=t[n],"__lodash_hash_undefined__"===n?F:n):ci.call(t,n)?t[n]:F},Tn.prototype.has=function(n){var t=this.__data__;return Gi?t[n]!==F:ci.call(t,n)},Tn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Gi&&t===F?"__lodash_hash_undefined__":t,this},Nn.prototype.clear=function(){this.__data__=[],this.size=0},Nn.prototype.delete=function(n){var t=this.__data__;return n=lt(t,n),!(0>n)&&(n==t.length-1?t.pop():wi.call(t,n,1),
    --this.size,true)},Nn.prototype.get=function(n){var t=this.__data__;return n=lt(t,n),0>n?F:t[n][1]},Nn.prototype.has=function(n){return-1<lt(this.__data__,n)},Nn.prototype.set=function(n,t){var r=this.__data__,e=lt(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Pn.prototype.clear=function(){this.size=0,this.__data__={hash:new Tn,map:new(Zi||Nn),string:new Tn}},Pn.prototype.delete=function(n){return n=we(this,n).delete(n),this.size-=n?1:0,n},Pn.prototype.get=function(n){return we(this,n).get(n);
  },Pn.prototype.has=function(n){return we(this,n).has(n)},Pn.prototype.set=function(n,t){var r=we(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},qn.prototype.add=qn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},qn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.clear=function(){this.__data__=new Nn,this.size=0},Vn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Vn.prototype.get=function(n){
    return this.__data__.get(n)},Vn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Nn){var e=r.__data__;if(!Zi||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Pn(e)}return r.set(n,t),this.size=r.size,this};var oo=Zr(Et),fo=Zr(Ot,true),co=qr(),ao=qr(true),lo=Hi?function(n,t){return Hi.set(n,t),n}:Nu,so=Ei?function(n,t){return Ei(n,"toString",{configurable:true,enumerable:false,value:Fu(t),writable:true})}:Nu,ho=Oi||function(n){
      return Zn.clearTimeout(n)},po=Vi&&1/D(new Vi([,-0]))[1]==N?function(n){return new Vi(n)}:qu,_o=Hi?function(n){return Hi.get(n)}:qu,vo=Wi?function(n){return null==n?[]:(n=ni(n),f(Wi(n),function(t){return ji.call(n,t)}))}:Ku,go=Wi?function(n){for(var t=[];n;)s(t,vo(n)),n=bi(n);return t}:Ku,yo=zt;(Pi&&"[object DataView]"!=yo(new Pi(new ArrayBuffer(1)))||Zi&&"[object Map]"!=yo(new Zi)||qi&&"[object Promise]"!=yo(qi.resolve())||Vi&&"[object Set]"!=yo(new Vi)||Ki&&"[object WeakMap]"!=yo(new Ki))&&(yo=function(n){
    var t=zt(n);if(n=(n="[object Object]"==t?n.constructor:F)?Fe(n):"")switch(n){case Yi:return"[object DataView]";case Qi:return"[object Map]";case Xi:return"[object Promise]";case no:return"[object Set]";case to:return"[object WeakMap]"}return t});var bo=oi?gu:Gu,xo=Me(lo),jo=Ii||function(n,t){return Zn.setTimeout(n,t)},wo=Me(so),mo=function(n){n=lu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return en.test(n)&&t.push(""),n.replace(un,function(n,r,e,u){
    t.push(e?u.replace(vn,"$1"):r||n)}),t}),Ao=lr(function(n,t){return _u(n)?jt(n,kt(t,1,_u,true)):[]}),ko=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),je(r,2)):[]}),Eo=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),F,r):[]}),Oo=lr(function(n){var t=l(n,Sr);return t.length&&t[0]===n[0]?Ut(t):[]}),So=lr(function(n){var t=Ge(n),r=l(n,Sr);return t===Ge(r)?t=F:r.pop(),r.length&&r[0]===n[0]?Ut(r,je(t,2)):[]}),Io=lr(function(n){var t=Ge(n),r=l(n,Sr);return(t=typeof t=="function"?t:F)&&r.pop(),
    r.length&&r[0]===n[0]?Ut(r,F,t):[]}),Ro=lr(He),zo=ge(function(n,t){var r=null==n?0:n.length,e=vt(n,t);return fr(n,l(t,function(n){return Re(n,r)?+n:n}).sort(Ur)),e}),Wo=lr(function(n){return wr(kt(n,1,_u,true))}),Bo=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),wr(kt(n,1,_u,true),je(t,2))}),Lo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return wr(kt(n,1,_u,true),F,t)}),Uo=lr(function(n,t){return _u(n)?jt(n,t):[]}),Co=lr(function(n){return Er(f(n,_u))}),Do=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),
    Er(f(n,_u),je(t,2))}),Mo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return Er(f(n,_u),F,t)}),To=lr(Ye),$o=lr(function(n){var t=n.length,t=1<t?n[t-1]:F,t=typeof t=="function"?(n.pop(),t):F;return Qe(n,t)}),Fo=ge(function(n){function t(t){return vt(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Mn&&Re(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(F),
                                                                                                                                                                                                                                                                                                                                                                                       n})):this.thru(t)}),No=Nr(function(n,t,r){ci.call(n,r)?++n[r]:_t(n,r,1)}),Po=Yr(Ze),Zo=Yr(qe),qo=Nr(function(n,t,r){ci.call(n,r)?n[r].push(t):_t(n,r,[t])}),Vo=lr(function(n,t,e){var u=-1,i=typeof t=="function",o=pu(n)?Hu(n.length):[];return oo(n,function(n){o[++u]=i?r(t,n,e):Dt(n,t,e)}),o}),Ko=Nr(function(n,t,r){_t(n,r,t)}),Go=Nr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ho=lr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&ze(n,t[0],t[1])?t=[]:2<r&&ze(t[0],t[1],t[2])&&(t=[t[0]]),
    rr(n,kt(t,1),[])}),Jo=Si||function(){return Zn.Date.now()},Yo=lr(function(n,t,r){var e=1;if(r.length)var u=C(r,xe(Yo)),e=32|e;return le(n,e,t,r,u)}),Qo=lr(function(n,t,r){var e=3;if(r.length)var u=C(r,xe(Qo)),e=32|e;return le(t,e,n,r,u)}),Xo=lr(function(n,t){return xt(n,1,t)}),nf=lr(function(n,t,r){return xt(n,Iu(t)||0,r)});lu.Cache=Pn;var tf=lr(function(n,t){t=1==t.length&&af(t[0])?l(t[0],S(je())):l(kt(t,1),S(je()));var e=t.length;return lr(function(u){for(var i=-1,o=Mi(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);
    return r(n,this,u)})}),rf=lr(function(n,t){return le(n,32,F,t,C(t,xe(rf)))}),ef=lr(function(n,t){return le(n,64,F,t,C(t,xe(ef)))}),uf=ge(function(n,t){return le(n,256,F,F,F,t)}),of=oe(Wt),ff=oe(function(n,t){return n>=t}),cf=Mt(function(){return arguments}())?Mt:function(n){return xu(n)&&ci.call(n,"callee")&&!ji.call(n,"callee")},af=Hu.isArray,lf=Hn?S(Hn):Tt,sf=Bi||Gu,hf=Jn?S(Jn):$t,pf=Yn?S(Yn):Nt,_f=Qn?S(Qn):qt,vf=Xn?S(Xn):Vt,gf=nt?S(nt):Kt,df=oe(Jt),yf=oe(function(n,t){return n<=t}),bf=Pr(function(n,t){
    if(Le(t)||pu(t))Tr(t,Lu(t),n);else for(var r in t)ci.call(t,r)&&at(n,r,t[r])}),xf=Pr(function(n,t){Tr(t,Uu(t),n)}),jf=Pr(function(n,t,r,e){Tr(t,Uu(t),n,e)}),wf=Pr(function(n,t,r,e){Tr(t,Lu(t),n,e)}),mf=ge(vt),Af=lr(function(n){return n.push(F,se),r(jf,F,n)}),kf=lr(function(n){return n.push(F,he),r(Rf,F,n)}),Ef=ne(function(n,t,r){n[t]=r},Fu(Nu)),Of=ne(function(n,t,r){ci.call(n,t)?n[t].push(r):n[t]=[r]},je),Sf=lr(Dt),If=Pr(function(n,t,r){nr(n,t,r)}),Rf=Pr(function(n,t,r,e){nr(n,t,r,e)}),zf=ge(function(n,t){
    var r={};if(null==n)return r;var e=false;t=l(t,function(t){return t=Rr(t,n),e||(e=1<t.length),t}),Tr(n,ye(n),r),e&&(r=dt(r,7,pe));for(var u=t.length;u--;)mr(r,t[u]);return r}),Wf=ge(function(n,t){return null==n?{}:er(n,t)}),Bf=ae(Lu),Lf=ae(Uu),Uf=Gr(function(n,t,r){return t=t.toLowerCase(),n+(r?Mu(t):t)}),Cf=Gr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Df=Gr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Mf=Kr("toLowerCase"),Tf=Gr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase();
  }),$f=Gr(function(n,t,r){return n+(r?" ":"")+Nf(t)}),Ff=Gr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Nf=Kr("toUpperCase"),Pf=lr(function(n,t){try{return r(n,F,t)}catch(n){return vu(n)?n:new Yu(n)}}),Zf=ge(function(n,t){return u(t,function(t){t=$e(t),_t(n,t,Yo(n[t],n))}),n}),qf=Qr(),Vf=Qr(true),Kf=lr(function(n,t){return function(r){return Dt(r,n,t)}}),Gf=lr(function(n,t){return function(r){return Dt(n,r,t)}}),Hf=re(l),Jf=re(o),Yf=re(_),Qf=ie(),Xf=ie(true),nc=te(function(n,t){return n+t},0),tc=ce("ceil"),rc=te(function(n,t){
    return n/t},1),ec=ce("floor"),uc=te(function(n,t){return n*t},1),ic=ce("round"),oc=te(function(n,t){return n-t},0);return On.after=function(n,t){if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){if(1>--n)return t.apply(this,arguments)}},On.ary=iu,On.assign=bf,On.assignIn=xf,On.assignInWith=jf,On.assignWith=wf,On.at=mf,On.before=ou,On.bind=Yo,On.bindAll=Zf,On.bindKey=Qo,On.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return af(n)?n:[n]},
    On.chain=Xe,On.chunk=function(n,t,r){if(t=(r?ze(n,t,r):t===F)?1:Di(Ou(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Hu(Ri(r/t));e<r;)i[u++]=vr(n,e,e+=t);return i},On.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u},On.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Hu(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return s(af(r)?Mr(r):[r],kt(t,1))},On.cond=function(n){var t=null==n?0:n.length,e=je();return n=t?l(n,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if("function"!=typeof n[1])throw new ei("Expected a function");return[e(n[0]),n[1]]}):[],lr(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})},On.conforms=function(n){return yt(dt(n,1))},On.constant=Fu,On.countBy=No,On.create=function(n,t){var r=io(n);return null==t?r:ht(r,t)},On.curry=fu,On.curryRight=cu,On.debounce=au,On.defaults=Af,On.defaultsDeep=kf,On.defer=Xo,On.delay=nf,On.difference=Ao,On.differenceBy=ko,On.differenceWith=Eo,On.drop=function(n,t,r){var e=null==n?0:n.length;
    return e?(t=r||t===F?1:Ou(t),vr(n,0>t?0:t,e)):[]},On.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0,0>t?0:t)):[]},On.dropRightWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true,true):[]},On.dropWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true):[]},On.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&ze(n,t,r)&&(r=0,e=u),u=n.length,r=Ou(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:Ou(e),0>e&&(e+=u),e=r>e?0:Su(e);r<e;)n[r++]=t;
    return n},On.filter=function(n,t){return(af(n)?f:At)(n,je(t,3))},On.flatMap=function(n,t){return kt(uu(n,t),1)},On.flatMapDeep=function(n,t){return kt(uu(n,t),N)},On.flatMapDepth=function(n,t,r){return r=r===F?1:Ou(r),kt(uu(n,t),r)},On.flatten=Ve,On.flattenDeep=function(n){return(null==n?0:n.length)?kt(n,N):[]},On.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===F?1:Ou(t),kt(n,t)):[]},On.flip=function(n){return le(n,512)},On.flow=qf,On.flowRight=Vf,On.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){
    var u=n[t];e[u[0]]=u[1]}return e},On.functions=function(n){return null==n?[]:St(n,Lu(n))},On.functionsIn=function(n){return null==n?[]:St(n,Uu(n))},On.groupBy=qo,On.initial=function(n){return(null==n?0:n.length)?vr(n,0,-1):[]},On.intersection=Oo,On.intersectionBy=So,On.intersectionWith=Io,On.invert=Ef,On.invertBy=Of,On.invokeMap=Vo,On.iteratee=Pu,On.keyBy=Ko,On.keys=Lu,On.keysIn=Uu,On.map=uu,On.mapKeys=function(n,t){var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,t(n,e,u),n)}),r},On.mapValues=function(n,t){
    var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,e,t(n,e,u))}),r},On.matches=function(n){return Qt(dt(n,1))},On.matchesProperty=function(n,t){return Xt(n,dt(t,1))},On.memoize=lu,On.merge=If,On.mergeWith=Rf,On.method=Kf,On.methodOf=Gf,On.mixin=Zu,On.negate=su,On.nthArg=function(n){return n=Ou(n),lr(function(t){return tr(t,n)})},On.omit=zf,On.omitBy=function(n,t){return Cu(n,su(je(t)))},On.once=function(n){return ou(2,n)},On.orderBy=function(n,t,r,e){return null==n?[]:(af(t)||(t=null==t?[]:[t]),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            r=e?F:r,af(r)||(r=null==r?[]:[r]),rr(n,t,r))},On.over=Hf,On.overArgs=tf,On.overEvery=Jf,On.overSome=Yf,On.partial=rf,On.partialRight=ef,On.partition=Go,On.pick=Wf,On.pickBy=Cu,On.property=Vu,On.propertyOf=function(n){return function(t){return null==n?F:It(n,t)}},On.pull=Ro,On.pullAll=He,On.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,je(r,2)):n},On.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,F,r):n},On.pullAt=zo,On.range=Qf,On.rangeRight=Xf,On.rearg=uf,On.reject=function(n,t){
    return(af(n)?f:At)(n,su(je(t,3)))},On.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=je(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return fr(n,u),r},On.rest=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=t===F?t:Ou(t),lr(n,t)},On.reverse=Je,On.sampleSize=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),(af(n)?ot:hr)(n,t)},On.set=function(n,t,r){return null==n?n:pr(n,t,r)},On.setWith=function(n,t,r,e){return e=typeof e=="function"?e:F,
    null==n?n:pr(n,t,r,e)},On.shuffle=function(n){return(af(n)?ft:_r)(n)},On.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&ze(n,t,r)?(t=0,r=e):(t=null==t?0:Ou(t),r=r===F?e:Ou(r)),vr(n,t,r)):[]},On.sortBy=Ho,On.sortedUniq=function(n){return n&&n.length?br(n):[]},On.sortedUniqBy=function(n,t){return n&&n.length?br(n,je(t,2)):[]},On.split=function(n,t,r){return r&&typeof r!="number"&&ze(n,t,r)&&(t=r=F),r=r===F?4294967295:r>>>0,r?(n=zu(n))&&(typeof t=="string"||null!=t&&!_f(t))&&(t=jr(t),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                !t&&Bn.test(n))?zr($(n),0,r):n.split(t,r):[]},On.spread=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=null==t?0:Di(Ou(t),0),lr(function(e){var u=e[t];return e=zr(e,0,t),u&&s(e,u),r(n,this,e)})},On.tail=function(n){var t=null==n?0:n.length;return t?vr(n,1,t):[]},On.take=function(n,t,r){return n&&n.length?(t=r||t===F?1:Ou(t),vr(n,0,0>t?0:t)):[]},On.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0>t?0:t,e)):[]},On.takeRightWhile=function(n,t){
    return n&&n.length?Ar(n,je(t,3),false,true):[]},On.takeWhile=function(n,t){return n&&n.length?Ar(n,je(t,3)):[]},On.tap=function(n,t){return t(n),n},On.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ei("Expected a function");return bu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),au(n,t,{leading:e,maxWait:t,trailing:u})},On.thru=nu,On.toArray=ku,On.toPairs=Bf,On.toPairsIn=Lf,On.toPath=function(n){return af(n)?l(n,$e):Au(n)?[n]:Mr(mo(zu(n)))},On.toPlainObject=Ru,
    On.transform=function(n,t,r){var e=af(n),i=e||sf(n)||gf(n);if(t=je(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:bu(n)&&gu(o)?io(bi(n)):{}}return(i?u:Et)(n,function(n,e,u){return t(r,n,e,u)}),r},On.unary=function(n){return iu(n,1)},On.union=Wo,On.unionBy=Bo,On.unionWith=Lo,On.uniq=function(n){return n&&n.length?wr(n):[]},On.uniqBy=function(n,t){return n&&n.length?wr(n,je(t,2)):[]},On.uniqWith=function(n,t){return t=typeof t=="function"?t:F,n&&n.length?wr(n,F,t):[]},On.unset=function(n,t){return null==n||mr(n,t);
    },On.unzip=Ye,On.unzipWith=Qe,On.update=function(n,t,r){return null==n?n:pr(n,t,Ir(r)(It(n,t)),void 0)},On.updateWith=function(n,t,r,e){return e=typeof e=="function"?e:F,null!=n&&(n=pr(n,t,Ir(r)(It(n,t)),e)),n},On.values=Du,On.valuesIn=function(n){return null==n?[]:I(n,Uu(n))},On.without=Uo,On.words=$u,On.wrap=function(n,t){return rf(Ir(t),n)},On.xor=Co,On.xorBy=Do,On.xorWith=Mo,On.zip=To,On.zipObject=function(n,t){return Or(n||[],t||[],at)},On.zipObjectDeep=function(n,t){return Or(n||[],t||[],pr);
    },On.zipWith=$o,On.entries=Bf,On.entriesIn=Lf,On.extend=xf,On.extendWith=jf,Zu(On,On),On.add=nc,On.attempt=Pf,On.camelCase=Uf,On.capitalize=Mu,On.ceil=tc,On.clamp=function(n,t,r){return r===F&&(r=t,t=F),r!==F&&(r=Iu(r),r=r===r?r:0),t!==F&&(t=Iu(t),t=t===t?t:0),gt(Iu(n),t,r)},On.clone=function(n){return dt(n,4)},On.cloneDeep=function(n){return dt(n,5)},On.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,5,t)},On.cloneWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,4,t)},
    On.conformsTo=function(n,t){return null==t||bt(n,t,Lu(t))},On.deburr=Tu,On.defaultTo=function(n,t){return null==n||n!==n?t:n},On.divide=rc,On.endsWith=function(n,t,r){n=zu(n),t=jr(t);var e=n.length,e=r=r===F?e:gt(Ou(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},On.eq=hu,On.escape=function(n){return(n=zu(n))&&Y.test(n)?n.replace(H,et):n},On.escapeRegExp=function(n){return(n=zu(n))&&fn.test(n)?n.replace(on,"\\{{PRELOAD_SCRIPTS}}"):n},On.every=function(n,t,r){var e=af(n)?o:wt;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3));
    },On.find=Po,On.findIndex=Ze,On.findKey=function(n,t){return v(n,je(t,3),Et)},On.findLast=Zo,On.findLastIndex=qe,On.findLastKey=function(n,t){return v(n,je(t,3),Ot)},On.floor=ec,On.forEach=ru,On.forEachRight=eu,On.forIn=function(n,t){return null==n?n:co(n,je(t,3),Uu)},On.forInRight=function(n,t){return null==n?n:ao(n,je(t,3),Uu)},On.forOwn=function(n,t){return n&&Et(n,je(t,3))},On.forOwnRight=function(n,t){return n&&Ot(n,je(t,3))},On.get=Wu,On.gt=of,On.gte=ff,On.has=function(n,t){return null!=n&&ke(n,t,Bt);
    },On.hasIn=Bu,On.head=Ke,On.identity=Nu,On.includes=function(n,t,r,e){return n=pu(n)?n:Du(n),r=r&&!e?Ou(r):0,e=n.length,0>r&&(r=Di(e+r,0)),mu(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<d(n,t,r)},On.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),d(n,t,r)):-1},On.inRange=function(n,t,r){return t=Eu(t),r===F?(r=t,t=0):r=Eu(r),n=Iu(n),n>=Mi(t,r)&&n<Di(t,r)},On.invoke=Sf,On.isArguments=cf,On.isArray=af,On.isArrayBuffer=lf,On.isArrayLike=pu,On.isArrayLikeObject=_u,
    On.isBoolean=function(n){return true===n||false===n||xu(n)&&"[object Boolean]"==zt(n)},On.isBuffer=sf,On.isDate=hf,On.isElement=function(n){return xu(n)&&1===n.nodeType&&!wu(n)},On.isEmpty=function(n){if(null==n)return true;if(pu(n)&&(af(n)||typeof n=="string"||typeof n.splice=="function"||sf(n)||gf(n)||cf(n)))return!n.length;var t=yo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(Le(n))return!Ht(n).length;for(var r in n)if(ci.call(n,r))return false;return true},On.isEqual=function(n,t){return Ft(n,t);
    },On.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:F)?r(n,t):F;return e===F?Ft(n,t,F,r):!!e},On.isError=vu,On.isFinite=function(n){return typeof n=="number"&&Li(n)},On.isFunction=gu,On.isInteger=du,On.isLength=yu,On.isMap=pf,On.isMatch=function(n,t){return n===t||Pt(n,t,me(t))},On.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:F,Pt(n,t,me(t),r)},On.isNaN=function(n){return ju(n)&&n!=+n},On.isNative=function(n){if(bo(n))throw new Yu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
      return Zt(n)},On.isNil=function(n){return null==n},On.isNull=function(n){return null===n},On.isNumber=ju,On.isObject=bu,On.isObjectLike=xu,On.isPlainObject=wu,On.isRegExp=_f,On.isSafeInteger=function(n){return du(n)&&-9007199254740991<=n&&9007199254740991>=n},On.isSet=vf,On.isString=mu,On.isSymbol=Au,On.isTypedArray=gf,On.isUndefined=function(n){return n===F},On.isWeakMap=function(n){return xu(n)&&"[object WeakMap]"==yo(n)},On.isWeakSet=function(n){return xu(n)&&"[object WeakSet]"==zt(n)},On.join=function(n,t){
      return null==n?"":Ui.call(n,t)},On.kebabCase=Cf,On.last=Ge,On.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==F&&(u=Ou(r),u=0>u?Di(e+u,0):Mi(u,e-1)),t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=g(n,b,u,true);return n},On.lowerCase=Df,On.lowerFirst=Mf,On.lt=df,On.lte=yf,On.max=function(n){return n&&n.length?mt(n,Nu,Wt):F},On.maxBy=function(n,t){return n&&n.length?mt(n,je(t,2),Wt):F},On.mean=function(n){return x(n,Nu)},On.meanBy=function(n,t){return x(n,je(t,2))},On.min=function(n){
      return n&&n.length?mt(n,Nu,Jt):F},On.minBy=function(n,t){return n&&n.length?mt(n,je(t,2),Jt):F},On.stubArray=Ku,On.stubFalse=Gu,On.stubObject=function(){return{}},On.stubString=function(){return""},On.stubTrue=function(){return true},On.multiply=uc,On.nth=function(n,t){return n&&n.length?tr(n,Ou(t)):F},On.noConflict=function(){return Zn._===this&&(Zn._=pi),this},On.noop=qu,On.now=Jo,On.pad=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return!t||e>=t?n:(t=(t-e)/2,ee(zi(t),r)+n+ee(Ri(t),r))},On.padEnd=function(n,t,r){
      n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?n+ee(t-e,r):n},On.padStart=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?ee(t-e,r)+n:n},On.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),$i(zu(n).replace(an,""),t||0)},On.random=function(n,t,r){if(r&&typeof r!="boolean"&&ze(n,t,r)&&(t=r=F),r===F&&(typeof t=="boolean"?(r=t,t=F):typeof n=="boolean"&&(r=n,n=F)),n===F&&t===F?(n=0,t=1):(n=Eu(n),t===F?(t=n,n=0):t=Eu(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Fi(),Mi(n+r*(t-n+$n("1e-"+((r+"").length-1))),t)):cr(n,t);
    },On.reduce=function(n,t,r){var e=af(n)?h:m,u=3>arguments.length;return e(n,je(t,4),r,u,oo)},On.reduceRight=function(n,t,r){var e=af(n)?p:m,u=3>arguments.length;return e(n,je(t,4),r,u,fo)},On.repeat=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),ar(zu(n),t)},On.replace=function(){var n=arguments,t=zu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},On.result=function(n,t,r){t=Rr(t,n);var e=-1,u=t.length;for(u||(u=1,n=F);++e<u;){var i=null==n?F:n[$e(t[e])];i===F&&(e=u,i=r),n=gu(i)?i.call(n):i;
    }return n},On.round=ic,On.runInContext=w,On.sample=function(n){return(af(n)?tt:sr)(n)},On.size=function(n){if(null==n)return 0;if(pu(n))return mu(n)?T(n):n.length;var t=yo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Ht(n).length},On.snakeCase=Tf,On.some=function(n,t,r){var e=af(n)?_:gr;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3))},On.sortedIndex=function(n,t){return dr(n,t)},On.sortedIndexBy=function(n,t,r){return yr(n,t,je(r,2))},On.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){
      var e=dr(n,t);if(e<r&&hu(n[e],t))return e}return-1},On.sortedLastIndex=function(n,t){return dr(n,t,true)},On.sortedLastIndexBy=function(n,t,r){return yr(n,t,je(r,2),true)},On.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=dr(n,t,true)-1;if(hu(n[r],t))return r}return-1},On.startCase=$f,On.startsWith=function(n,t,r){return n=zu(n),r=null==r?0:gt(Ou(r),0,n.length),t=jr(t),n.slice(r,r+t.length)==t},On.subtract=oc,On.sum=function(n){return n&&n.length?k(n,Nu):0},On.sumBy=function(n,t){return n&&n.length?k(n,je(t,2)):0;
    },On.template=function(n,t,r){var e=On.templateSettings;r&&ze(n,t,r)&&(t=F),n=zu(n),t=jf({},t,e,se),r=jf({},t.imports,e.imports,se);var u,i,o=Lu(r),f=I(r,o),c=0;r=t.interpolate||An;var a="__p+='";r=ti((t.escape||An).source+"|"+r.source+"|"+(r===nn?gn:An).source+"|"+(t.evaluate||An).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(kn,B),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),
      e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(q,""):a).replace(V,"$1").replace(K,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Pf(function(){return Qu(o,l+"return "+a).apply(F,f)}),t.source=a,vu(t))throw t;return t},On.times=function(n,t){if(n=Ou(n),1>n||9007199254740991<n)return[];
      var r=4294967295,e=Mi(n,4294967295);for(t=je(t),n-=4294967295,e=E(e,t);++r<n;)t(r);return e},On.toFinite=Eu,On.toInteger=Ou,On.toLength=Su,On.toLower=function(n){return zu(n).toLowerCase()},On.toNumber=Iu,On.toSafeInteger=function(n){return n?gt(Ou(n),-9007199254740991,9007199254740991):0===n?n:0},On.toString=zu,On.toUpper=function(n){return zu(n).toUpperCase()},On.trim=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(cn,""):n&&(t=jr(t))?(n=$(n),r=$(t),t=z(n,r),r=W(n,r)+1,zr(n,t,r).join("")):n;
    },On.trimEnd=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(ln,""):n&&(t=jr(t))?(n=$(n),t=W(n,$(t))+1,zr(n,0,t).join("")):n},On.trimStart=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(an,""):n&&(t=jr(t))?(n=$(n),t=z(n,$(t)),zr(n,t).join("")):n},On.truncate=function(n,t){var r=30,e="...";if(bu(t))var u="separator"in t?t.separator:u,r="length"in t?Ou(t.length):r,e="omission"in t?jr(t.omission):e;n=zu(n);var i=n.length;if(Bn.test(n))var o=$(n),i=o.length;if(r>=i)return n;if(i=r-T(e),1>i)return e;
      if(r=o?zr(o,0,i).join(""):n.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),_f(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=ti(u.source,zu(dn.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else n.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},On.unescape=function(n){return(n=zu(n))&&J.test(n)?n.replace(G,ut):n},On.uniqueId=function(n){var t=++ai;return zu(n)+t},On.upperCase=Ff,On.upperFirst=Nf,On.each=ru,On.eachRight=eu,On.first=Ke,
    Zu(On,function(){var n={};return Et(On,function(t,r){ci.call(On.prototype,r)||(n[r]=t)}),n}(),{chain:false}),On.VERSION="4.17.4",u("bind bindKey curry curryRight partial partialRight".split(" "),function(n){On[n].placeholder=On}),u(["drop","take"],function(n,t){Mn.prototype[n]=function(r){r=r===F?1:Di(Ou(r),0);var e=this.__filtered__&&!t?new Mn(this):this.clone();return e.__filtered__?e.__takeCount__=Mi(r,e.__takeCount__):e.__views__.push({size:Mi(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Mn.prototype[n+"Right"]=function(t){
      return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Mn.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:je(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Mn.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Mn.prototype[n]=function(){return this.__filtered__?new Mn(this):this[r](1);
    }}),Mn.prototype.compact=function(){return this.filter(Nu)},Mn.prototype.find=function(n){return this.filter(n).head()},Mn.prototype.findLast=function(n){return this.reverse().find(n)},Mn.prototype.invokeMap=lr(function(n,t){return typeof n=="function"?new Mn(this):this.map(function(r){return Dt(r,n,t)})}),Mn.prototype.reject=function(n){return this.filter(su(je(n)))},Mn.prototype.slice=function(n,t){n=Ou(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Mn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            t!==F&&(t=Ou(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Mn.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Mn.prototype.toArray=function(){return this.take(4294967295)},Et(Mn.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=On[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(On.prototype[t]=function(){function t(n){return n=u.apply(On,s([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Mn,a=f[0],l=c||af(o);
      l&&r&&typeof a=="function"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Mn(this),o=n.apply(o,f),o.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(o,h)):a&&c?n.apply(this,f):(o=this.thru(t),a?e?o.value()[0]:o.value():o)})}),u("pop push shift sort splice unshift".split(" "),function(n){var t=ui[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);On.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){
      var u=this.value();return t.apply(af(u)?u:[],n)}return this[r](function(r){return t.apply(af(r)?r:[],n)})}}),Et(Mn.prototype,function(n,t){var r=On[t];if(r){var e=r.name+"";(Ji[e]||(Ji[e]=[])).push({name:t,func:r})}}),Ji[Xr(F,2).name]=[{name:"wrapper",func:F}],Mn.prototype.clone=function(){var n=new Mn(this.__wrapped__);return n.__actions__=Mr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mr(this.__views__),
      n},Mn.prototype.reverse=function(){if(this.__filtered__){var n=new Mn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Mn.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=af(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Mi(n,f+s);break;case"takeRight":f=Di(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,
        o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Mi(n,this.__takeCount__),!e||!u&&i==n&&l==n)return kr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},On.prototype.at=Fo,On.prototype.chain=function(){return Xe(this)},On.prototype.commit=function(){return new zn(this.value(),this.__chain__)},On.prototype.next=function(){this.__values__===F&&(this.__values__=ku(this.value()));
      var n=this.__index__>=this.__values__.length;return{done:n,value:n?F:this.__values__[this.__index__++]}},On.prototype.plant=function(n){for(var t,r=this;r instanceof Sn;){var e=Pe(r);e.__index__=0,e.__values__=F,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},On.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Mn?(this.__actions__.length&&(n=new Mn(this)),n=n.reverse(),n.__actions__.push({func:nu,args:[Je],thisArg:F}),new zn(n,this.__chain__)):this.thru(Je);
    },On.prototype.toJSON=On.prototype.valueOf=On.prototype.value=function(){return kr(this.__wrapped__,this.__actions__)},On.prototype.first=On.prototype.head,Ai&&(On.prototype[Ai]=tu),On}();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=it, define(function(){return it})):Vn?((Vn.exports=it)._=it,qn._=it):Zn._=it}).call(this);</script>

<script>// Copyright 2017-2020, University of Colorado Boulder

/**
 * Utilities for creating and manipulating the unique identifiers assigned to instrumented PhET-iO instances, aka
 * phetioIDs.
 *
 * Many of these functions' jsdoc is rendered and visible publicly to PhET-iO client. Those sections should be
 * marked, see top level comment in Client.js about private vs public documentation
 *
 * @author Chris Malley (PixelZoom, Inc.)
 * @author Sam Reid (PhET Interactive Simulations)
 */
( function() {
  'use strict';

  // define the phetio global
  window.phetio = window.phetio || {};

  // constants
  const SEPARATOR = '.';
  const GROUP_SEPARATOR = '_';
  const GENERAL_COMPONENT_NAME = 'general';
  const GLOBAL_COMPONENT_NAME = 'global';
  const HOME_SCREEN_COMPONENT_NAME = 'homeScreen';
  const MODEL_COMPONENT_NAME = 'model';
  const VIEW_COMPONENT_NAME = 'view';
  const CONTROLLER_COMPONENT_NAME = 'controller';

  /**
   * Helpful methods for manipulating phetioIDs. Used to minimize the amount of duplicated logic specific to the string
   * structure of the phetioID. Available in the main PhET-iO js import.
   * @namespace
   */
  window.phetio.PhetioIDUtils = {

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Appends a component to an existing phetioID to create a new unique phetioID for the component.
     * @example
     * append( 'myScreen.myControlPanel', 'myComboBox' )
     * -->  'myScreen.myControlPanel.myComboBox'
     * @public
     * @param {string} phetioID - the ID of the PhET-iO element
     * @param {string|string[]} componentNames - the name or list of names to append to the ID
     * @returns {string} - the appended phetioID
     */
    append: function( phetioID, ...componentNames ) {
      componentNames.forEach( componentName => {
        assert && assert( componentName.indexOf( SEPARATOR ) === -1, 'separator appears in componentName: ' + componentName );
        phetioID += SEPARATOR + componentName;
      } );
      return phetioID;
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Given a phetioID for a PhET-iO element, get the part of that ID that pertains to the component (basically the
     * tail piece).
     * @example
     * getComponentName( 'myScreen.myControlPanel.myComboBox' )
     * -->  'myComboBox'
     * @public
     * @param {string} phetioID - the ID of the PhET-iO element
     * @returns {string} - the component name
     */
    getComponentName: function( phetioID ) {
      assert && assert( phetioID.length > 0 );
      const indexOfLastSeparator = phetioID.lastIndexOf( SEPARATOR );
      if ( indexOfLastSeparator === -1 ) {
        return phetioID;
      }
      else {
        return phetioID.substring( indexOfLastSeparator + 1, phetioID.length );
      }
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Given a phetioID for a PhET-iO element, get the phetioID of the parent component.
     * @example
     * getParentID( 'myScreen.myControlPanel.myComboBox' )
     * -->  'myScreen.myControlPanel'
     * @public
     * @param {string} phetioID - the ID of the PhET-iO element
     * @returns {string|null} - the phetioID of the parent, or null if there is no parent
     */
    getParentID: function( phetioID ) {
      const indexOfLastSeparator = phetioID.lastIndexOf( SEPARATOR );
      return indexOfLastSeparator === -1 ? null : phetioID.substring( 0, indexOfLastSeparator );
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Given a phetioID for a instrumented object, get a string that can be used to assign an ID to a DOM element
     * @param {string} phetioID - the ID of the PhET-iO element
     * @returns {string}
     * @public
     */
    getDOMElementID: function( phetioID ) {
      return 'phetioID:' + phetioID;
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The root sim ID has a nested "general" ID which contains several simulation-level components.  This
     * method can be used for convenience in accessing its child elements.
     * @param {Client} Client - the Client type, not a Client instance
     * @param {string|string[]} componentNames - to append to the general ID stub
     * @returns {string}
     * @example
     * getGeneralID( phetio.Client, 'activeProperty' );
     * -->  'faradaysLaw.general.activeProperty'
     *
     * getGeneralID( phetio.Client, [ 'mySubComponent', 'activeProperty' ] );
     * -->  'faradaysLaw.general.mySubComponent.activeProperty'
     * @public
     */
    getGeneralID: function( Client, ...componentNames ) {
      return window.phetio.PhetioIDUtils.append( Client.CAMEL_CASE_SIMULATION_NAME, ...[ GENERAL_COMPONENT_NAME, ...componentNames ] );
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Get the screen id from the phetioID.
     * @example
     * getScreenID( 'sim.myScreen.model.property' )
     * --> sim.myScreen
     * getScreenID( 'sim.myScreen' )
     * --> sim.myScreen
     * getScreenID( 'sim.general.activeProperty' )
     * --> null
     * @param {string} phetioID
     * @returns {string|null} - null if there is no screen component name in the phetioID
     */
    getScreenID: function( phetioID ) {
      const screenIDParts = [];
      const phetioIDParts = phetioID.split( SEPARATOR );
      for ( let i = 0; i < phetioIDParts.length; i++ ) {
        const componentPart = phetioIDParts[ i ];
        screenIDParts.push( componentPart );
        const screenMarker = 'Screen';
        const indexOfScreenMarker = componentPart.indexOf( screenMarker );
        if ( indexOfScreenMarker > 0 && indexOfScreenMarker + screenMarker.length === componentPart.length ) { // endsWith proxy
          return screenIDParts.join( SEPARATOR );
        }
      }
      return null;
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * Get the index number from the component name of the component name provided.
     * @param {string} componentName
     * @returns {number}
     * @example
     * getGroupElementIndex( 'particle_1' )
     * --> 1
     * @public
     */
    getGroupElementIndex: function( componentName ) {
      assert && assert( componentName.indexOf( window.phetio.PhetioIDUtils.GROUP_SEPARATOR ) >= 0,
        'component name for phetioID should have group element syntax' );
      return parseInt( componentName.split( window.phetio.PhetioIDUtils.GROUP_SEPARATOR )[ 1 ], 10 );
    },


    /**
     * Returns true if the potential ancestor is indeed an ancestor of the potential descendant, but not the same phetioID
     * @param {string} potentialAncestorPhetioID
     * @param {string} potentialDescendantPhetioID
     * @returns {boolean}
     * @public
     */
    isAncestor: function( potentialAncestorPhetioID, potentialDescendantPhetioID ) {
      const ancestorComponents = potentialAncestorPhetioID.split( SEPARATOR );
      const descendantComponents = potentialDescendantPhetioID.split( SEPARATOR );
      for ( let i = 0; i < ancestorComponents.length; i++ ) {
        if ( ancestorComponents[ i ] !== descendantComponents[ i ] ) {
          return false;
        }
      }

      // not the same child
      return potentialDescendantPhetioID !== potentialAncestorPhetioID;
    },

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The separator used to piece together a phet-io ID.
     * @type {string}
     * @constant
     * @public
     */
    SEPARATOR: SEPARATOR,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The separator used to specify the count of a element in a group.
     * @type {string}
     * @constant
     * @public
     */
    GROUP_SEPARATOR: GROUP_SEPARATOR,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for the id section that holds phet-io elements general to all simulations.
     * @type {string}
     * @constant
     * @public
     */
    GENERAL_COMPONENT_NAME: GENERAL_COMPONENT_NAME,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for the id section that holds simulation specific elements that don't belong in a screen.
     * @type {string}
     * @constant
     * @public
     */
    GLOBAL_COMPONENT_NAME: GLOBAL_COMPONENT_NAME,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for the id section that holds the home screen.
     * @type {string}
     * @constant
     * @public
     */
    HOME_SCREEN_COMPONENT_NAME: HOME_SCREEN_COMPONENT_NAME,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for an id section that holds model specific elements.
     * @type {string}
     * @constant
     * @public
     */
    MODEL_COMPONENT_NAME: MODEL_COMPONENT_NAME,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for an id section that holds view specific elements.
     * @type {string}
     * @constant
     * @public
     */
    VIEW_COMPONENT_NAME: VIEW_COMPONENT_NAME,

    // Private Doc: The below jsdoc is public to the phet-io api documentation. Change wisely.
    /**
     * The component name for an id section that holds controller specific elements.
     * @type {string}
     * @constant
     * @public
     */
    CONTROLLER_COMPONENT_NAME: CONTROLLER_COMPONENT_NAME
  };
} )();</script>
<script type="module">/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {// Copyright 2020, University of Colorado Boulder

/**
 * Hot module replacement (HMR) enables reloading and replacing a single module within a running, stateful application.
 * The general pattern is to listen for a module replacement and re-run downstream code that uses the module.
 * For example:
 *
 *  // In a constructor
 *  const initializeWavesNode = () => {
 *   this.wavesNode && this.removeChild( this.wavesNode );
 *   this.wavesNode = new WavesNode( model, this.layoutBounds );
 *   this.addChild( this.wavesNode );
 *  };
 *
 *  initializeWavesNode();
 *
 * // Enable hot module replacement for fast iteration
 * isHMR && module.hot.accept( './WavesNode.js', initializeWavesNode );
 *
 * This can be used in concert with `grunt webpack-dev-server` from a simulation directory to launch a server that
 * supports hot module replacement.
 *
 * Note that when using HMR with a model module, you must pass re-instantiated model elements to corresponding view
 * elements, which can be prohibitively difficult. On the other hand, using HMR on a view can be simpler because often a
 * view element only needs to be swapped out in one place (say, replacing a node). Likewise, using HMR for static or
 * utility functions/modules works very well, since no instances need to be swapped out.
 *
 * When running with webpack-dev-server, a global "module" exists, but window.module does not.  In unbuilt mode,
 * neither "module" nor window.module exist.  This code factors out the check for the global "module".
 *
 * Since this code relies on a try/catch block, you probably should blackbox it in chrome dev tools, see
 * https://developer.chrome.com/devtools/docs/blackboxing#how-to-blackbox
 *
 * TODO: Make sure this gets stripped out on builds, see https://github.com/phetsims/chipper/issues/953
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

let isHMR;

try {
  isHMR = module && module.hot;
}
catch( e ) {
  isHMR = false;
}

// Not namespaced because Namespace relies on this file

/* harmony default export */ __webpack_exports__["a"] = (isHMR);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: C:/Users/Michael/PhET/git/phet-core/js/isHMR.js
var isHMR = __webpack_require__(0);

// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/Namespace.js
// Copyright 2015-2020, University of Colorado Boulder

/**
 * @author Jonathan Olson
 * @author Chris Malley (PixelZoom, Inc.)
 */



class Namespace_Namespace {
  /**
   * @param {string} name
   */
  constructor( name ) {

    this.name = name; // @public (read-only)

    if ( window.phet ) {
      assert && assert( !window.phet[ name ], 'namespace ' + name + ' already exists' );
      window.phet[ name ] = this;
    }
  }

  /**
   * Registers a key-value pair with the namespace.
   *
   * If there are no dots ('.') in the key, it will be assigned to the namespace. For example:
   * - x.register( 'A', A );
   * will set x.A = A.
   *
   * If the key contains one or more dots ('.'), it's treated somewhat like a path expression. For instance, if the
   * following is called:
   * - x.register( 'A.B.C', C );
   * then the register function will navigate to the object x.A.B and add x.A.B.C = C.
   *
   * @param {string} key
   * @param {*} value
   * @returns {*} value, for chaining
   * @public
   */
  register( key, value ) {

    // When using hot module replacement, a module will be loaded and initialized twice, and hence its namespace.register
    // function will be called twice.  This should not be an assertion error.

    // If the key isn't compound (doesn't contain '.'), we can just look it up on this namespace
    if ( key.indexOf( '.' ) < 0 ) {
      if ( !isHMR["a" /* default */] ) {
        assert && assert( !this[ key ], key + ' is already registered for namespace ' + this.name );
      }
      this[ key ] = value;
    }
    // Compound (contains '.' at least once). x.register( 'A.B.C', C ) should set x.A.B.C.
    else {
      const keys = key.split( '.' ); // e.g. [ 'A', 'B', 'C' ]

      // Walk into the namespace, verifying that each level exists. e.g. parent => x.A.B
      let parent = this; // eslint-disable-line consistent-this
      for ( let i = 0; i < keys.length - 1; i++ ) { // for all but the last key

        if ( !isHMR["a" /* default */] ) {
          assert && assert( !!parent[ keys[ i ] ],
            [ this.name ].concat( keys.slice( 0, i + 1 ) ).join( '.' ) + ' needs to be defined to register ' + key );
        }

        parent = parent[ keys[ i ] ];
      }

      // Write into the inner namespace, e.g. x.A.B[ 'C' ] = C
      const lastKey = keys[ keys.length - 1 ];

      if ( !isHMR["a" /* default */] ) {
        assert && assert( !parent[ lastKey ], key + ' is already registered for namespace ' + this.name );
      }

      parent[ lastKey ] = value;
    }

    return value;
  }
}

/* harmony default export */ var js_Namespace = (Namespace_Namespace);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/phetCore.js
// Copyright 2013-2020, University of Colorado Boulder




const phetCore = new js_Namespace( 'phetCore' );

// Namespace can't require this file, so we register it as a special case.
phetCore.register( 'Namespace', js_Namespace );

/* harmony default export */ var js_phetCore = (phetCore);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/merge.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Like Lodash's _.merge, this will recursively merge nested options objects provided that the keys end in 'Options'
 * (case sensitive) and they are pure object literals.
 * That is, they must be defined by `... = { ... }` or `somePropOptions: { ... }`.
 * Non object literals (arrays, functions, and inherited types) or anything with an extra prototype will all throw
 * assertion errors if passed in as an arg or as a value to a `*Options` field.
 *
 * @author Michael Barlow (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */



// constants
const OPTIONS_SUFFIX = 'Options';

/**
 * @param  {Object} target - the object literal that will have keys set to it
 * @param  {...<Object|null>} sources
 * @returns {Object}
 */
function merge( target, ...sources ) {
  assert && assertIsMergeable( target );
  assert && assert( target !== null, 'target should not be null' ); // assertIsMergeable supports null
  assert && assert( sources.length > 0, 'at least one source expected' );

  _.each( sources, source => {
    if ( source ) {
      assert && assertIsMergeable( source );
      for ( const property in source ) {
        if ( source.hasOwnProperty( property ) ) {
          const sourceProperty = source[ property ];

          // Recurse on keys that end with 'Options', but not on keys named 'Options'.
          if ( _.endsWith( property, OPTIONS_SUFFIX ) && property !== OPTIONS_SUFFIX ) {

            // *Options property value cannot be undefined, if truthy, it we be validated with assertIsMergeable via recursion.
            assert && assert( sourceProperty !== undefined, 'nested *Options should not be undefined' );
            target[ property ] = merge( target[ property ] || {}, sourceProperty );
          }
          else {
            target[ property ] = sourceProperty;
          }
        }
      }
    }
  } );
  return target;
}

/**
 * Asserts that the object is compatible with merge. That is, it's a POJSO.
 * This function must be called like: assert && assertIsMergeable( arg );
 * @param {Object|null} object
 */
function assertIsMergeable( object ) {
  assert( object === null ||
          ( object && typeof object === 'object' && Object.getPrototypeOf( object ) === Object.prototype ),
    'object is not compatible with merge' );

  if ( object !== null ) {
    // ensure that options keys are not ES5 setters or getters
    Object.keys( object ).forEach( prop => {
      const ownPropertyDescriptor = Object.getOwnPropertyDescriptor( object, prop );
      assert( !ownPropertyDescriptor.hasOwnProperty( 'set' ),
        'cannot use merge with an object that has a setter' );
      assert( !ownPropertyDescriptor.hasOwnProperty( 'get' ),
        'cannot use merge with an object that has a getter' );
    } );
  }
}

js_phetCore.register( 'merge', merge );
/* harmony default export */ var js_merge = (merge);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/tandemNamespace.js
// Copyright 2015-2020, University of Colorado Boulder

/**
 * Creates the namespace for this repository.  By convention, this should have been declared in a file "tandem.js"
 * But that filename was already used for Tandem.js, so we use the alternate convention discussed in:
 * https://github.com/phetsims/tandem/issues/5#issuecomment-162597651
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */



/* harmony default export */ var tandemNamespace = (new js_Namespace( 'tandem' ));
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/axon.js
// Copyright 2013-2020, University of Colorado Boulder




/* harmony default export */ var axon = (new js_Namespace( 'axon' ));
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/Enumeration.js
// Copyright 2018-2020, University of Colorado Boulder

/**
 * Creates a simple enumeration, with most of the boilerplate.
 *
 * An Enumeration can be created like this:
 *
 *   const CardinalDirection = Enumeration.byKeys( [ 'NORTH', 'SOUTH', 'EAST', 'WEST' ] );
 *
 * OR using rich values like so:
 *
 *   const CardinalDirection = Enumeration.byMap( {NORTH: northObject, SOUTH: southObject, EAST: eastObject, WEST: westObject} );
 *
 * and values are referenced like this:
 *
 *   CardinalDirection.NORTH;
 *   CardinalDirection.SOUTH;
 *   CardinalDirection.EAST;
 *   CardinalDirection.WEST;
 *
 *   CardinalDirection.VALUES;
 *   // returns [ CardinalDirection.NORTH, CardinalDirection.SOUTH, CardinalDirection.EAST, CardinalDirection.WEST ]
 *
 * And support for checking whether any value is a value of the enumeration:
 *
 *   CardinalDirection.includes( CardinalDirection.NORTH ); // true
 *   CardinalDirection.includes( CardinalDirection.SOUTHWEST ); // false
 *   CardinalDirection.includes( 'NORTH' ); // false, values are not strings
 *
 * Conventions for using Enumeration, from https://github.com/phetsims/phet-core/issues/53:
 *
 * (1) Enumerations are named like classes/types. Nothing in the name needs to identify that they are Enumerations.
 *     See the example above: CardinalDirection, not CardinalDirectionEnum or CardinalDirectionEnumeration.
 *
 * (2) Enumeration values are named like constants, using uppercase. See the example above.
 *
 * (3) If an Enumeration is closely related to some class, then make it a static field of that class. If an
 *     Enumeration is specific to a Property, then the Enumeration should likely be owned by the class that
 *     owns that Property.
 *
 * (4) If an Enumeration is not closely related to some class, then put the Enumeration in its own .js file.
 *     Do not combine multiple Enumerations into one file.
 *
 * (5) If a Property takes an Enumeration value, its validation typically looks like this:
 *
 *     const cardinalDirectionProperty = new Property( CardinalDirection.NORTH, {
 *       validValues: CardinalDirection.VALUES
 *     }
 *
 * (6) Values of the Enumeration are considered instances of the Enumeration in documentation. For example, a method
 *     that that takes an Enumeration value as an argument would be documented like this:
 *
 *     // @param {Scene} mode - value from Scene Enumeration
 *     setSceneMode( mode ) {
 *       assert && assert( Scene.includes( mode ) );
 *       //...
 *     }
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */




class Enumeration_Enumeration {

  /**
   * @param {Object} config - must provide keys such as {keys:['RED','BLUE]}
   *                          - or map such as {map:{RED: myRedValue, BLUE: myBlueValue}}
   *
   * @private - clients should use Enumeration.byKeys or Enumeration.byMap
   */
  constructor( config ) {
    assert && assert( config, 'config must be provided' );

    const keysProvided = !!config.keys;
    const mapProvided = !!config.map;
    assert && assert( keysProvided !== mapProvided, 'must provide one or the other but not both of keys/map' );

    const keys = config.keys || Object.keys( config.map );
    const map = config.map || {};

    config = js_merge( {

      // {string|null} Will be appended to the EnumerationIO documentation, if provided
      phetioDocumentation: null,

      // {function(Enumeration):|null} If provided, it will be called as beforeFreeze( enumeration ) just before the
      // enumeration is frozen. Since it's not possible to modify the enumeration after
      // it is frozen (e.g. adding convenience functions), and there is no reference to
      // the enumeration object beforehand, this allows defining custom values/methods
      // on the enumeration object itself.
      beforeFreeze: null
    }, config );

    assert && assert( Array.isArray( keys ), 'Values should be an array' );
    assert && assert( _.uniq( keys ).length === keys.length, 'There should be no duplicated values provided' );
    assert && keys.forEach( value => assert( typeof value === 'string', 'Each value should be a string' ) );
    assert && keys.forEach( value => assert( /^[A-Z][A-Z0-9_]*$/g.test( value ),
      'Enumeration values should be uppercase alphanumeric with underscores and begin with a letter' ) );
    assert && assert( !_.includes( keys, 'VALUES' ),
      'This is the name of a built-in provided value, so it cannot be included as an enumeration value' );
    assert && assert( !_.includes( keys, 'KEYS' ),
      'This is the name of a built-in provided value, so it cannot be included as an enumeration value' );
    assert && assert( !_.includes( keys, 'includes' ),
      'This is the name of a built-in provided value, so it cannot be included as an enumeration value' );

    // @public (phet-io) - provides additional documentation for PhET-iO which can be viewed in studio
    // Note this uses the same term as used by PhetioObject, but via a different channel.
    this.phetioDocumentation = config.phetioDocumentation;

    // @public {string[]} (read-only) - the string keys of the enumeration
    this.KEYS = keys;

    // @public {Object[]} (read-only) - the object values of the enumeration
    this.VALUES = [];

    keys.forEach( key => {
      const value = map[ key ] || {};

      // Set attributes of the enumeration value
      assert && assert( value.name === undefined, 'rich enumeration values cannot provide their own name attribute' );
      assert && assert( value.toString === Object.prototype.toString, 'rich enumeration values cannot provide their own toString' );

      // @public {string} (read-only) - PhET-iO public API relies on this mapping, do not change it lightly
      value.name = key;

      // @public {function():string} (read-only)
      value.toString = () => key;

      // Assign to the enumeration
      this[ key ] = value;
      this.VALUES.push( value );
    } );

    config.beforeFreeze && config.beforeFreeze( this );
    assert && Object.freeze( this );
    assert && Object.freeze( this.VALUES );
    assert && Object.freeze( this.KEYS );
    assert && keys.forEach( key => assert && Object.freeze( map[ key ] ) );
  }

  /**
   * Checks whether the given value is a value of this enumeration. Should generally be used for assertions
   * @public
   *
   * @param {Object} value
   * @returns {boolean}
   */
  includes( value ) {
    return _.includes( this.VALUES, value );
  }

  /**
   * Creates an enumeration based on the provided string array
   * @param {string[]} keys - such as ['RED','BLUE']
   * @param {Object} [options]
   * @returns {Enumeration}
   * @public
   */
  static byKeys( keys, options ) {
    assert && assert( Array.isArray( keys ), 'keys must be an array' );
    assert && assert( !options || options.keys === undefined );
    return new Enumeration_Enumeration( js_merge( { keys: keys }, options ) );
  }

  /**
   * Creates a "rich" enumeration based on the provided map
   * @param {Object} map - such as {RED: myRedValue, BLUE: myBlueValue}
   * @param {Object} [options]
   * @returns {Enumeration}
   * @public
   */
  static byMap( map, options ) {
    assert && assert( !options || options.map === undefined );
    if ( assert ) {
      const values = _.values( map );
      assert && assert( values.length >= 1, 'must have at least 2 entries in an enumeration' );
      assert && assert( _.every( values, value => value.constructor === values[ 0 ].constructor ), 'Values must have same constructor' );
    }
    return new Enumeration_Enumeration( js_merge( { map: map }, options ) );
  }
}

js_phetCore.register( 'Enumeration', Enumeration_Enumeration );
/* harmony default export */ var js_Enumeration = (Enumeration_Enumeration);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/ValidatorDef.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * The definition file for "validators" used to validate values. This file holds associated logic that validates the
 * schema of the "validator" object, as well as testing if a value adheres to the restrictions provided by a validator.
 * See validate.js for usage with assertions to check that values are valid.
 *
 * Examples:
 *
 * A {ValidatorDef} (commonly know as "validator") that only accepts number values:
 * { valueType: 'number' }
 *
 * A validator that only accepts the numbers "2" or "3":
 * { valueType: 'number', validValues: [ 2, 3 ] }
 *
 * A validator that accepts any Object:
 * { valueType: Object }
 *
 * A validator that accepts Enumeration values:
 * { valueType: MyEnumeration }
 * and/or
 * { validValues: MyEnumeration.VALUES }
 *
 * A validator that accepts a string or a number greater than 2:
 * { isValidValue: value => { typeof value === 'string' || (typeof value === 'number' && value > 2)} }
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */





// constants
const TYPEOF_STRINGS = [ 'string', 'number', 'boolean', 'function' ];

// constants
const ASSERTIONS_FALSE = { assertions: false };
const ASSERTIONS_TRUE = { assertions: true };

// Key names are verbose so this can be mixed into other contexts like AXON/Property. `undefined` and `null` have the
// same semantics so that we can use this feature without having extend and allocate new objects at every validation.
const VALIDATOR_KEYS = [

  // {function|string|null} type of the value.
  // If {function}, the function must be a constructor.
  // If {string}, the string must be one of the primitive types listed in TYPEOF_STRINGS.
  // If {null|undefined}, the value must be null (which doesn't make sense until the next line of doc)
  // If {Array.<string|function|null|undefined>}, each item must be a legal value as explained in the above doc
  // Unused if null.
  // Examples:
  // valueType: Vector2
  // valueType: 'string'
  // valueType: 'number',
  // valueType: [ 'number', null ]
  // valueType: [ 'number', 'string', Node, null ]
  'valueType',

  // {*[]|null} valid values for this Property. Unused if null.
  // Example:
  // validValues: [ 'horizontal', 'vertical' ]
  'validValues',

  // {function|null} function that validates the value. Single argument is the value, returns boolean. Unused if null.
  // Example:
  // isValidValue: function( value ) { return Number.isInteger( value ) && value >= 0; }
  'isValidValue',

  // This option takes the same types as are supported with `valueType`. This option is to specify the type of the
  // elements of an array. For this option to valid, `valueType` must be not also be provided. It is assumed that
  // valueType is `Array`.
  'arrayElementType',

  // {IOType} - A IOType used to specify the public typing for PhET-iO. Each IOType must have a
  // `validator` key specified that can be used for validation. See IOType for an example.
  'phetioType'
];

/**
 * @typedef {Object} ValidatorDef
 * See above documentation for details
 * @property {function} [isValidValue]
 * @property {*} [valueType]
 * @property {Array.<*>} [validValues]
 * @property {Array.<*>} [arrayElementType]
 * @property {function()} [phetioType] - IO Type
 */
const ValidatorDef = {

  /**
   * Throws assertion errors if the validator is invalid.
   * @param {ValidatorDef} validator
   * @param {Object} [options]
   * @returns {boolean}
   * @public
   */
  isValidValidator( validator, options ) {

    options = options || ASSERTIONS_FALSE;// Poor man's extend

    if ( !( validator instanceof Object ) ) {
      assert && options.assertions && assert( false,
        'validator must be an Object' );
      return false;
    }
    if ( !( validator.hasOwnProperty( 'isValidValue' ) ||
            validator.hasOwnProperty( 'valueType' ) ||
            validator.hasOwnProperty( 'arrayElementType' ) ||
            validator.hasOwnProperty( 'validValues' ) ||
            validator.hasOwnProperty( 'phetioType' ) ) ) {
      assert && options.assertions && assert( false,
        'validator must have at least one of: isValidValue, valueType, validValues' );
      return false;
    }

    if ( validator.hasOwnProperty( 'valueType' ) && !validateValueOrElementType( validator.valueType, options ) ) {
      return false;
    }

    if ( validator.hasOwnProperty( 'arrayElementType' ) ) {
      if ( validator.hasOwnProperty( 'valueType' ) ) {
        assert && options.assertions && assert( false, 'valueType is redundant with arrayElementType. valueType is Array.' );
        return false;
      }
      if ( !validateValueOrElementType( validator.arrayElementType, options ) ) {
        return false;
      }
    }

    if ( validator.hasOwnProperty( 'isValidValue' ) ) {
      if ( !( typeof validator.isValidValue === 'function' ||
              validator.isValidValue === null ||
              validator.isValidValue === undefined ) ) {
        assert && options.assertions && assert( false, `isValidValue must be a function: ${validator.isValidValue}` );
        return false;
      }
    }

    if ( validator.validValues !== undefined && validator.validValues !== null ) {
      if ( !Array.isArray( validator.validValues ) ) {
        assert && options.assertions && assert( false, `validValues must be an array: ${validator.validValues}` );
        return false;
      }

      // Make sure each validValue matches the other rules, if any.
      const validatorWithoutValidValues = _.omit( validator, 'validValues' );
      if ( ValidatorDef.containsValidatorKey( validatorWithoutValidValues ) ) {
        for ( let i = 0; i < validator.validValues.length; i++ ) {
          if ( !ValidatorDef.isValueValid( validator.validValues[ i ], validatorWithoutValidValues ) ) {
            assert && options.assertions && assert( false, 'Item not valid: ' + validator.validValues[ i ] );
            return false;
          }
        }
      }
    }

    if ( validator.hasOwnProperty( 'phetioType' ) ) {
      if ( !( validator.phetioType && validator.phetioType.validator ) ) {
        assert && options.assertions && assert( false, 'validator needed for phetioType: ' + ( validator.phetioType && validator.phetioType.typeName ) );
        return false;
      }
      return ValidatorDef.isValidValidator( validator.phetioType.validator, options );
    }
    return true;
  },

  /**
   * @private
   * @param valueType
   * @param {Object} [options] - required, options from isValidValidator
   * @returns {boolean} - true if valid
   */
  validateValueType( valueType, options ) {
    if ( !( typeof valueType === 'function' ||
            typeof valueType === 'string' ||
            valueType instanceof js_Enumeration ||
            valueType === null ||
            valueType === undefined ) ) {
      assert && options.assertions && assert( false,
        `valueType must be {function|string|Enumeration|null|undefined}, valueType=${valueType}` );
      return false;
    }

    // {string} valueType must be one of the primitives in TYPEOF_STRINGS, for typeof comparison
    if ( typeof valueType === 'string' ) {
      if ( !_.includes( TYPEOF_STRINGS, valueType ) ) {
        assert && options.assertions && assert( false, `valueType not a supported primitive types: ${valueType}` );
        return false;
      }
    }
    return true;
  },

  /**
   * Throws assertion errors if the validator is invalid.
   * @param {ValidatorDef} validator
   * @public
   */
  validateValidator( validator ) {
    if ( assert ) {

      // Specify that assertions should be thrown if there are problems during the validation check.
      ValidatorDef.isValidValidator( validator, ASSERTIONS_TRUE );
    }
  },

  /**
   * @param {ValidatorDef} validator - object which may or may not contain validation keys
   * @returns {boolean}
   * @public
   */
  containsValidatorKey( validator ) {
    for ( let i = 0; i < VALIDATOR_KEYS.length; i++ ) {
      if ( validator.hasOwnProperty( VALIDATOR_KEYS[ i ] ) ) {
        return true;
      }
    }
    return false;
  },

  /**
   * Determines whether a value is valid (returning a boolean value), and optionally throws an assertion error if the
   * value is not valid.  The reason assertions are (optionally) thrown from this method is so that we can have more
   * specific error messages.
   *
   * @param {Object|null} value
   * @param {ValidatorDef} validator
   * @param {Object} [options]
   * @returns {boolean} - whether the value is valid
   * @throws {Error} assertion error if not valid and options.assertions is true
   * @public
   */
  isValueValid( value, validator, options ) {

    options = js_merge( {

      // {boolean} - By default validation will always check the validity of the  validator itself.  However, for types like
      // Property and Emitter re-checking the validator every time the Property value changes or the Emitter emits
      // wastes cpu. Hence cases like those can opt-out
      validateValidator: true,

      // if true, throw an assertion "instead" of waiting to return a boolean
      assertions: false
    }, options );

    // Use the same policy for whether to throw assertions when checking the validator itself.
    if ( options.validateValidator && !axon.ValidatorDef.isValidValidator( validator, options ) ) {
      assert && options.assertions && assert( false, 'Invalid validator' );
      return false;
    }

    // Check valueType, which can be an array, string, type, or null
    if ( validator.hasOwnProperty( 'valueType' ) ) {
      const valueType = validator.valueType;
      if ( Array.isArray( valueType ) ) {

        // Only one should be valid, so error out if none of them returned valid
        // Hard code assertions false because most will fail, instead have a general assertion here.
        if ( !_.some( valueType.map( typeInArray => ValidatorDef.isValueValidValueType( value, typeInArray, ASSERTIONS_FALSE ) ) ) ) {
          assert && options.assertions && assert( false, `value not valid for any valueType in ${valueType}, value: ${value}` );
          return false;
        }
      }
      else if ( valueType ) {
        if ( !ValidatorDef.isValueValidValueType( value, valueType, options ) ) {
          return false;
        }
      }
    }

    if ( validator.hasOwnProperty( 'arrayElementType' ) ) {
      const arrayElementType = validator.arrayElementType;

      // If using arrayElementType, then the value should be an array. No need for assertions, because nested
      // isValueValid will assert out if asserting.
      if ( !ValidatorDef.isValueValid( value, { valueType: Array }, options ) ) {
        return false;
      }

      // every element in the array should pass
      if ( !_.every( value.map( arrayElement => {

        // if the type is an array, then handle it like we did for valueType, with _.some
        if ( Array.isArray( arrayElementType ) ) {
          if ( !_.some( arrayElementType.map( typeInArray => ValidatorDef.isValueValidValueType( arrayElement, typeInArray, ASSERTIONS_FALSE ) ) ) ) {
            assert && options.assertions && assert( false, `array element not valid for any arrayElementType in ${arrayElementType}, value: ${arrayElement}` );
            return false;
          }
          return true;
        }
        else {

          // if not an array, then just check the array element
          return ValidatorDef.isValueValidValueType( arrayElement, validator.arrayElementType, options );
        }
      } ) ) ) {
        return false; // if every element didn't pass, then return false
      }
    }

    if ( validator.hasOwnProperty( 'validValues' ) && validator.validValues.indexOf( value ) === -1 ) {
      assert && options.assertions && assert( false, `value not in validValues: ${value}` );
      return false;
    }
    if ( validator.hasOwnProperty( 'isValidValue' ) && !validator.isValidValue( value ) ) {
      assert && options.assertions && assert( false, `value failed isValidValue: ${value}` );
      return false;
    }
    if ( validator.hasOwnProperty( 'phetioType' ) &&

         // Never assert, instead handling it here for the better assertion message.
         !ValidatorDef.isValueValid( value, validator.phetioType.validator, ASSERTIONS_FALSE ) ) {
      assert && options.assertions && assert( false, `value failed phetioType validator: ${value}` );
      return false;
    }
    return true;
  },

  /**
   * @param {Object|null} value
   * @param {string|function|null|undefined} valueType - see above definition, Array is not allowed in this method
   * @param {Object} [options] - not optional, should be passed in from isValidValue
   * @returns {boolean} - whether the value is a validType
   * @throws {Error} assertion error if not valid and options.assertions is true
   * @private
   */
  isValueValidValueType( value, valueType, options ) {
    if ( typeof valueType === 'string' && typeof value !== valueType ) { // primitive type
      assert && options.assertions && assert( false, `value should have typeof ${valueType}, value=${value}` );
      return false;
    }
    else if ( valueType === Array && !Array.isArray( value ) ) {
      assert && options.assertions && assert( false, `value should have been an array, value=${value}` );
      return false;
    }
    else if ( valueType instanceof js_Enumeration && !valueType.includes( value ) ) {
      assert && assert( false, 'value is not a member of Enumeration ' + valueType );
      return false;
    }
    else if ( typeof valueType === 'function' && !( value instanceof valueType ) ) { // constructor
      assert && options.assertions && assert( false, `value should be instanceof ${valueType.name}, value=${value}` );
      return false;
    }
    if ( valueType === null && value !== null ) {
      assert && options.assertions && assert( false, `value should be null, value=${value}` );
      return false;
    }
    return true;
  }
};

/**
 * Validate a type that can be a type, or an array of multiple types.
 * @param {*} type - see valueType documentation
 * @param {Object} [options] - see isValidValidator
 * @returns {boolean}
 */
const validateValueOrElementType = ( type, options ) => {
  if ( Array.isArray( type ) ) {

    // If not every type in the list is valid, then return false, pass options through verbatim.
    if ( !_.every( type.map( typeInArray => ValidatorDef.validateValueType( typeInArray, options ) ) ) ) {
      return false;
    }
  }
  else if ( type ) {
    if ( !ValidatorDef.validateValueType( type, options ) ) {
      return false;
    }
  }
  return true;
};

/**
 * @public
 * @type {string[]}
 */
ValidatorDef.VALIDATOR_KEYS = VALIDATOR_KEYS;

/**
 * General validator for validating that a string doesn't have template variables in it.
 * @public
 * @type {ValidatorDef}
 */
ValidatorDef.STRING_WITHOUT_TEMPLATE_VARS_VALIDATOR = {
  valueType: 'string',
  isValidValue: v => !/\{\{\w*\}\}/.test( v )
};

axon.register( 'ValidatorDef', ValidatorDef );
/* harmony default export */ var js_ValidatorDef = (ValidatorDef);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/validate.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Throws an assertion error if assertions are enabled and the value is invalid, otherwise returns the value.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */





/**
 * If assertions are enabled, assert out if the value does not adhere to the validator. No-op without assertions.
 * @param {*} value
 * @param {ValidatorDef} validator
 * @param {Object} [options] - see ValidatorDef.isValueValid()
 * @returns {*} - returns the input value for chaining
 * @public
 */
const validate = ( value, validator, options ) => {

  // Throws an error if not valid
  assert && js_ValidatorDef.isValueValid( value, validator, js_merge( { assertions: true }, options ) );
};


axon.register( 'validate', validate );
/* harmony default export */ var js_validate = (validate);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/required.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Validates that the passed in entry exists and returns that value if validation is successful.
 *
 * @author Denzell Barnett (PhET Interactive Simulations)
 */



/**
 * Checks if the value passed is defined
 *
 * @param {*} entry - value to be checked
 * @returns {*} Returns the passed in value
 */
function required( entry ) {
  assert && assert( entry !== undefined, 'Required field is undefined.' );
  return entry;
}

js_phetCore.register( 'required', required );

/* harmony default export */ var js_required = (required);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/PhetioConstants.js
// Copyright 2020, University of Colorado Boulder



/**
 * Constants used in PhET-iO. Defined in the tandem repo since they need to be accessed in non-private code, like
 * IOType.ObjectIO.
 * @author Sam Reid (PhET Interactive Simulations)
 */
const PhetioConstants = {

  // Suffix that is required for all IO Type class names
  IO_TYPE_SUFFIX: 'IO'
};

tandemNamespace.register( 'PhetioConstants', PhetioConstants );
/* harmony default export */ var js_PhetioConstants = (PhetioConstants);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/types/IOType.js
// Copyright 2020, University of Colorado Boulder

/**
 * IO Types form a synthetic type system used to describe PhET-iO Elements. A PhET-iO Element is an instrumented PhetioObject
 * that is interoperable from the "wrapper" frame (outside the sim frame). An IO Type includes documentation, methods,
 * names, serialization, etc.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */








// constants
const VALIDATE_OPTIONS_FALSE = { validateValidator: false };

// Defined at the bottom of this file
let ObjectIO = null;

/**
 * Estimate the core type name from a given IO Type name.
 * @param {string} ioTypeName
 * @returns {string}
 * @private
 */
const getCoreTypeName = ioTypeName => {
  const index = ioTypeName.indexOf( js_PhetioConstants.IO_TYPE_SUFFIX );
  assert && assert( index >= 0, 'IO should be in the type name' );
  return ioTypeName.substring( 0, index );
};

class IOType_IOType {

  /**
   * @param {string} ioTypeName - The name that this IOType will have in the public PhET-iO API. In general, this should
   *    only be word characters, ending in "IO". Parametric types are a special subset of IOTypes that include their
   *    parameters in their typeName. If an IOType's parameters are other IO Type(s), then they should be included within
   *    angle brackets, like "PropertyIO<BooleanIO>". Some other types use a more custom format for displaying their
   *    parameter types, in this case the parameter section of the type name (immediately following "IO") should begin
   *    with an open paren, "(". Thus the schema for a typeName could be defined (using regex) as `[A-Z]\w*IO([(<].*){0,1}`.
   *    Parameterized types should also include a `parameterTypes` field on the IOType.
   * @param {Object} config
   */
  constructor( ioTypeName, config ) {

    // For reference in the config
    const supertype = config.supertype || ObjectIO;

    config = js_merge( {

      /***** REQUIRED ****/

      // a validator, such as isValidValue | valueType | validValues

      /***** OPTIONAL ****/

      supertype: ObjectIO,

      // {Object<string,MethodObject>} The public methods available for this IO Type. Each method is not just a function,
      // but a collection of metadata about the method to be able to serialize parameters and return types and provide
      // better documentation.
      methods: {},

      // {string[]} The list of events that can be emitted at this level (does not include events from supertypes).
      events: [],

      // {string[]} The list of metadata keys that this IO Type adds to the metadata for its instances. If anything is
      // provided here, then corresponding PhetioObjects that use this IOType should override PhetioObject.getMetadata()
      // to add what keys they need for their specific type. It is HIGHLY recommended that you do not overwrite any
      // metadata key defined by a parent.
      metadataKeys: [],

      // {string} IO Types can specify the order that methods appear in the documentation by putting their names in this
      // list. This list is only for the methods defined at this level in the type hierarchy. After the methodOrder
      // specified, the methods follow in the order declared in the implementation (which isn't necessarily stable).
      methodOrder: [],

      // {IOType[]} For parametric types, they must indicate the types of the parameters here. 0 if nonparametric.
      parameterTypes: [],

      // {string} Documentation that appears in PhET-iO Studio, supports HTML markup.
      documentation: `IO Type for ${getCoreTypeName( ioTypeName )}`,

      // Functions cannot be sent from one iframe to another, so must be wrapped.  See phetioCommandProcessor.wrapFunction
      isFunctionType: false,

      /**** STATE ****/

      // {function(coreObject:*):*)} Serialize the core object. Most often this looks like an object literal that holds
      // data about the PhetioObject instance.
      toStateObject: supertype && supertype.toStateObject,

      // {function(stateObject:*):*} For Data Type Deserialization. Decodes the object from a state (see toStateObject)
      // into an instance of the core type.
      fromStateObject: supertype && supertype.fromStateObject,

      // {function(stateObject:*):Array[*]} For Dynamic Element Deserialization: converts the state object to arguments
      // for a `create` function in PhetioGroup or other PhetioDynamicElementContainer creation function. Note that
      // other non-serialized args (not dealt with here) may be supplied as closure variables. This function only needs
      // to be implemented on IO Types who's core type is phetioDynamicElement: true, such as PhetioDynamicElementContainer
      // elements.
      stateToArgsForConstructor: supertype && supertype.stateToArgsForConstructor,

      // {function(coreObject:*,stateObject:*)} For Reference Type Deserialization:  Applies the state (see toStateObject)
      // value to the instance. When setting PhET-iO state, this function will be called on an instrumented instance to set the
      // stateObject's value to it.
      // see https://github.com/phetsims/phet-io/blob/master/doc/phet-io-instrumentation-technical-guide.md#three-types-of-deserialization
      applyState: supertype && supertype.applyState,

      // For dynamic element containers, see examples in IOTypes for PhetioDynamicElementContainer classes
      addChildElement: supertype && supertype.addChildElement
    }, js_required( config ) );

    assert && assert( js_ValidatorDef.containsValidatorKey( config ), 'Validator is required' );
    assert && assert( Array.isArray( config.events ) );
    assert && assert( Array.isArray( config.metadataKeys ) );

    // @public (read-only)
    this.supertype = supertype;
    this.typeName = ioTypeName;
    this.documentation = config.documentation;
    this.methods = config.methods;
    this.events = config.events;
    this.metadataKeys = config.metadataKeys;
    this.methodOrder = config.methodOrder;
    this.parameterTypes = config.parameterTypes;
    this.validator = _.pick( config, js_ValidatorDef.VALIDATOR_KEYS );
    this.toStateObject = coreObject => {
      js_validate( coreObject, this.validator, VALIDATE_OPTIONS_FALSE );
      return config.toStateObject( coreObject );
    };
    this.fromStateObject = config.fromStateObject;
    this.stateToArgsForConstructor = config.stateToArgsForConstructor;
    this.applyState = ( coreObject, stateObject ) => {
      js_validate( coreObject, this.validator, VALIDATE_OPTIONS_FALSE );
      config.applyState( coreObject, stateObject );
    };
    this.isFunctionType = config.isFunctionType;
    this.addChildElement = config.addChildElement;

    assert && assert( supertype || this.typeName === 'ObjectIO', 'supertype is required' );
    assert && assert( !this.typeName.includes( '.' ), 'Dots should not appear in type names' );

    // Validate that parametric types look as expected
    // TODO: What about EmitterIO<> that has no parameter types?  See https://github.com/phetsims/tandem/issues/217
    // if ( this.typeName.includes( '<' ) ) {
    //   assert && assert( this.parameterTypes.length > 0,
    //     'angle bracket notation is only used for parametric IO Types that have parameter IO Types' );
    // }

    const splitOnParameters = this.typeName.split( /[<(]/ )[ 0 ];
    assert && assert( splitOnParameters.endsWith( js_PhetioConstants.IO_TYPE_SUFFIX ), `IO Type name must end with ${js_PhetioConstants.IO_TYPE_SUFFIX}` );
    assert && assert( this.hasOwnProperty( 'typeName' ), 'this.typeName is required' );

    // assert that each public method adheres to the expected schema
    Object.values( this.methods ).forEach( methodObject => {
      if ( typeof methodObject === 'object' ) {
        assert && assert( Array.isArray( methodObject.parameterTypes ), 'parameter types must be an array: ' + methodObject.parameterTypes );
        assert && assert( typeof methodObject.implementation === 'function', 'implementation must be of type function: ' + methodObject.implementation );
        assert && assert( typeof methodObject.documentation === 'string', 'documentation must be of type string: ' + methodObject.documentation );
        assert && methodObject.invocableForReadOnlyElements && assert( typeof methodObject.invocableForReadOnlyElements === 'boolean',
          'invocableForReadOnlyElements must be of type boolean: ' + methodObject.invocableForReadOnlyElements );
      }
    } );
    assert && assert( typeof this.documentation === 'string' && this.documentation.length > 0, 'documentation must be provided' );

    this.hasOwnProperty( 'methodOrder' ) && this.methodOrder.forEach( methodName => {
      assert && assert( this.methods[ methodName ], 'methodName not in public methods: ' + methodName );
    } );

    // TODO: support API checking, see https://github.com/phetsims/phet-io/issues/1657
    // if ( this.hasOwnProperty( 'api' ) ) {
    //   assert && assert( this.api instanceof Object, 'Object expected for api' );
    //   assert && assert( Object.getPrototypeOf( this.api ) === Object.prototype, 'no extra prototype allowed on API object' );
    // }

    // Make sure events are not listed again
    if ( supertype ) {
      const typeHierarchy = supertype.getTypeHierarchy();
      assert && this.events && this.events.forEach( event => {
        assert( !_.some( typeHierarchy, t => t.events.includes( event ) ),
          'this IOType should not declare event that parent also has: ' + event );
      } );

      assert && this.metadataKeys && this.metadataKeys.forEach( metadataKey => {
        assert( !_.some( typeHierarchy, t => t.metadataKeys.includes( metadataKey ) ),
          'this IOType should not declare  a metadataKey that parent also has: ' + metadataKey );
      } );
    }
    else {

      // The root IOType must supply all 4 state methods.
      assert && assert( typeof config.toStateObject === 'function', 'toStateObject must be defined' );
      assert && assert( typeof config.fromStateObject === 'function', 'fromStateObject must be defined' );
      assert && assert( typeof config.stateToArgsForConstructor === 'function', 'stateToArgsForConstructor must be defined' );
      assert && assert( typeof config.applyState === 'function', 'applyState must be defined' );
    }
  }

  /**
   * Gets an array of IOTypes of the self type and all the supertype ancestors.
   * @returns {IOType[]}
   * @public
   */
  getTypeHierarchy() {
    const array = [];
    let ioType = this; // eslint-disable-line
    while ( ioType ) {
      array.push( ioType );
      ioType = ioType.supertype;
    }
    return array;
  }

  /**
   * Convenience method for creating an IOType that forwards its state methods over to be handled by the core type. This
   * function will gracefully forward any supported deserialization methods, but requires the CoreType to have `toStateObject`.
   * @public
   * @param {string} ioTypeName - see IOType constuctor for details
   * @param {function} CoreType - the PhET "core" type class/constructor associated with this IOType being created
   * @param {Object} [options]
   * @returns {IOType}
   */
  static fromCoreType( ioTypeName, CoreType, options ) {

    if ( assert && options ) {
      assert && assert( !options.hasOwnProperty( 'valueType' ), 'fromCoreType sets its own valueType' );
      assert && assert( !options.hasOwnProperty( 'toStateObject' ), 'fromCoreType sets its own toStateObject' );
      assert && assert( !options.hasOwnProperty( 'stateToArgsForConstructor' ), 'fromCoreType sets its own stateToArgsForConstructor' );
      assert && assert( !options.hasOwnProperty( 'applyState' ), 'fromCoreType sets its own applyState' );
    }

    let coreTypeHasToStateObject = false;
    let coreTypeHasApplyState = false;

    let proto = CoreType.prototype;
    while ( proto ) {
      if ( typeof proto.toStateObject === 'function' ) {
        coreTypeHasToStateObject = true;
      }
      if ( typeof proto.applyState === 'function' ) {
        coreTypeHasApplyState = true;
      }
      proto = Object.getPrototypeOf( proto );
    }

    assert && assert( coreTypeHasToStateObject, 'toStateObject is required to be on the CoreType' );

    options = js_merge( {
      valueType: CoreType,
      toStateObject: coreType => coreType.toStateObject()
    }, options );

    if ( coreTypeHasApplyState ) {
      options.applyState = ( coreType, stateObject ) => coreType.applyState( stateObject );
    }
    if ( CoreType.fromStateObject ) {
      options.fromStateObject = CoreType.fromStateObject;
    }
    if ( CoreType.stateToArgsForConstructor ) {
      options.stateToArgsForConstructor = CoreType.stateToArgsForConstructor;
    }

    return new IOType_IOType( ioTypeName, options );
  }
}

ObjectIO = new IOType_IOType( 'ObjectIO', {
  isValidValue: () => true,
  supertype: null,
  documentation: 'The root of the IO Type hierarchy',
  toStateObject: coreObject => null,
  fromStateObject: stateObject => null,
  stateToArgsForConstructor: stateObject => [],
  applyState: ( coreObject, stateObject ) => { },
  metadataKeys: [
    'phetioTypeName',
    'phetioDocumentation',
    'phetioState',
    'phetioReadOnly',
    'phetioEventType',
    'phetioHighFrequency',
    'phetioPlayback',
    'phetioStudioControl',
    'phetioDynamicElement',
    'phetioIsArchetype',
    'phetioFeatured',
    'phetioArchetypePhetioID' // though this will only be present for dynamic elements
  ]
} );

// @public
IOType_IOType.ObjectIO = ObjectIO;

/**
 * @typedef {Object} MethodObject
 * @property {string} documentation
 * @property {function()} implementation - the function to execute when this method is called. This function's parameters
 *                                  will be based on `parameterTypes`, and should return the type specified by `returnType`
 * @property {IOType} returnType - the return IO Type of the method
 * @property {IOType[]} parameterTypes - the parameter IO Types for the method
 * @property {boolean} [invocableForReadOnlyElements=true] - by default, all methods are invocable for all elements.
 *    However, for some read-only elements, certain methods should not be invocable. In that case, they are marked as
 *    invocableForReadOnlyElements: false.
 */

tandemNamespace.register( 'IOType', IOType_IOType );
/* harmony default export */ var types_IOType = (IOType_IOType);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/types/FunctionIO.js
// Copyright 2018-2020, University of Colorado Boulder

/**
 * IO Type for JS's built-in function type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */




// {Map.<parameterTypeName:string, IOType>} - cache each parameterized IOType so that it is only created once
const cache = new Map();

/**
 * Parametric IO Type constructor--given return type and parameter types, this function returns a type wrapped IO Type for
 * that "class" of functions. "Class" here refers to the supported parameter and return IO Types.
 * This caching implementation should be kept in sync with the other parametric IO Type caching implementations.
 * @param {IOType} returnType - IO Type of the return type of the function that can support cross-frame serialization
 * @param {IOType[]} functionParameterTypes - IO Types for the individual arguments of the function.
 */
const FunctionIO = ( returnType, functionParameterTypes ) => {
  for ( let i = 0; i < functionParameterTypes.length; i++ ) {
    assert && assert( functionParameterTypes[ i ], 'parameter type was not truthy' );
  }
  assert && assert( returnType, 'return type was not truthy' );

  // REVIEW https://github.com/phetsims/tandem/issues/169 Why is this different than the typeName later in this file?
  const cacheKey = `${returnType.typeName}.${functionParameterTypes.map( type => type.typeName ).join( ',' )}`;

  if ( !cache.has( cacheKey ) ) {

    // gather a list of argument names for the documentation string
    let argsString = functionParameterTypes.map( parameterType => parameterType.typeName ).join( ', ' );
    if ( argsString === '' ) {
      argsString = 'VoidIO';
    }
    const parameterTypesString = functionParameterTypes.map( parameterType => parameterType.typeName ).join( ',' );

    cache.set( cacheKey, new types_IOType( `FunctionIO(${parameterTypesString})=>${returnType.typeName}`, {
      valueType: 'function',

      isFunctionType: true,

      // These are the parameters to this FunctionIO, not to the function it wraps. That is why it includes the return type.
      // NOTE: the order is very important, for instance phetioCommandProcessor relies on the parameters being before
      // the return type.  If we decide this is too brittle, perhaps we should subclass IOType to FunctionIOType, and it
      // can track its functionParameterTypes separately from the returnType.
      parameterTypes: functionParameterTypes.concat( [ returnType ] ),
      documentation: 'Wrapper for the built-in JS function type.<br>' +
                     '<strong>Arguments:</strong> ' + argsString + '<br>' +
                     '<strong>Return Type:</strong> ' + returnType.typeName
    } ) );
  }

  return cache.get( cacheKey );
};

tandemNamespace.register( 'FunctionIO', FunctionIO );
/* harmony default export */ var types_FunctionIO = (FunctionIO);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/types/VoidIO.js
// Copyright 2018-2020, University of Colorado Boulder

/**
 * IO Type use to signify a function has no return value.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */




/**
 * We sometimes use VoidIO as a workaround to indicate that an argument is passed in the simulation side, but
 * that it shouldn't be leaked to the PhET-iO client.
 *
 * @override
 * @public
 */
const VoidIO = new types_IOType( 'VoidIO', {
  isValidValue: () => true,
  documentation: 'Type for which there is no instance, usually to mark functions without a return value',
  toStateObject: object => undefined
} );

tandemNamespace.register( 'VoidIO', VoidIO );
/* harmony default export */ var types_VoidIO = (VoidIO);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/assertMutuallyExclusiveOptions.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Throws an assertion error if mutually exclusive options are specified.
 *
 * @example
 * assertMutuallyExclusiveOptions( { tree:1, flower:2 }, [ 'tree' ], [ 'flower' ] ) => error
 * assertMutuallyExclusiveOptions( { flower:2 }, [ 'tree' ], [ 'flower' ] ) => no error
 * assertMutuallyExclusiveOptions( { tree:1 }, [ 'tree' ], [ 'flower' ] ) => no error
 * assertMutuallyExclusiveOptions( { tree:1, mountain:2 }, [ 'tree', 'mountain' ], [ 'flower' ] ) => no error
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */



/**
 * @param {Object|null|undefined} options - an options object.  Could be before or after merge, and may therefore
 *                                        - be null or undefined
 * @param {...string[]} sets - families of mutually exclusive option keys, see examples above.
 */
const assertMutuallyExclusiveOptions = function( options, ...sets ) {
  if ( assert && options ) {

    // Determine which options are used from each set
    const usedElementsFromEachSet = sets.map( set => Object.keys( _.pick( options, ...set ) ) );

    // If any element is used from more than one set...
    if ( usedElementsFromEachSet.filter( usedElements => usedElements.length > 0 ).length > 1 ) {

      // Output the errant options.
      assert && assert( false, `Cannot simultaneously specify ${usedElementsFromEachSet.join( ' and ' )}` );
    }
  }
};

js_phetCore.register( 'assertMutuallyExclusiveOptions', assertMutuallyExclusiveOptions );
/* harmony default export */ var js_assertMutuallyExclusiveOptions = (assertMutuallyExclusiveOptions);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/TinyEmitter.js
// Copyright 2015-2020, University of Colorado Boulder

/**
 * Lightweight event & listener abstraction for a single event type.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */



// constants
const shuffleListeners = _.hasIn( window, 'phet.chipper.queryParameters' ) && phet.chipper.queryParameters.shuffleListeners;

class TinyEmitter {
  constructor() {

    // @private {Set<function>} - the listeners that will be called on emit
    this.listeners = new Set();

    // @private {Object[]} - during emit() keep track of iteration progress and guard listeners if mutated during emit()
    this.emitContexts = [];

    // @public {function|undefined} changeCount - Not defined usually because of memory usage. If defined, this will be
    // called when the listener count changes, e.g. changeCount( {number} listenersAddedQuantity ), with the number
    // being negative for listeners removed.

    // for production memory concerns; no need to keep this around.
    if ( assert ) {

      // @private {boolean} - to keep track if it has been disposed or not
      this.isDisposed = false;
    }
  }

  /**
   * Disposes an Emitter. All listeners are removed.
   * @public
   */
  dispose() {
    this.removeAllListeners();

    if ( assert ) {
      this.isDisposed = true;
    }
  }

  /**
   * Notify listeners
   * @public
   */
  emit() {
    assert && assert( !this.isDisposed, 'should not be called if disposed' );

    // Support for a query parameter that shuffles listeners, but bury behind assert so it will be stripped out on build
    // so it won't impact production performance.
    if ( assert && shuffleListeners ) {
      this.listeners = new Set( _.shuffle( Array.from( this.listeners ) ) ); // eslint-disable-line bad-sim-text
    }

    // Notify wired-up listeners, if any
    if ( this.listeners.size > 0 ) {

      const emitContext = {
        index: 0
        // listenerArray: [] // {Array.<function>|undefined} assigned if a mutation is made during emit
      };
      this.emitContexts.push( emitContext );

      for ( const listener of this.listeners ) {
        listener.apply( null, arguments );
        emitContext.index++;

        // If a listener was added or removed, we cannot continue processing the mutated Set, we must switch to
        // iterate over the guarded array
        if ( emitContext.listenerArray ) {
          break;
        }
      }

      // If the listeners were guarded during emit, we bailed out on the for..of and continue iterating over the original
      // listeners in order from where we left off.
      if ( emitContext.listenerArray ) {
        for ( let i = emitContext.index; i < emitContext.listenerArray.length; i++ ) {
          emitContext.listenerArray[ i ].apply( null, arguments );
        }
      }
      this.emitContexts.pop();
    }
  }

  /**
   * Adds a listener which will be called during emit.
   * @param {function} listener
   * @public
   */
  addListener( listener ) {
    assert && assert( !this.isDisposed, 'Cannot add a listener to a disposed TinyEmitter' );
    assert && assert( !this.hasListener( listener ), 'Cannot add the same listener twice' );

    // If a listener is added during an emit(), we must make a copy of the current list of listeners--the newly added
    // listener will be available for the next emit() but not the one in progress.  This is to match behavior with
    // removeListener.
    this.guardListeners();
    this.listeners.add( listener );

    this.changeCount && this.changeCount( 1 );
  }

  /**
   * Removes a listener
   * @param {function} listener
   * @public
   */
  removeListener( listener ) {

    // Throw an error when removing a non-listener (except when the Emitter has already been disposed, see
    // https://github.com/phetsims/sun/issues/394#issuecomment-419998231
    if ( assert && !this.isDisposed ) {
      assert( this.listeners.has( listener ), 'tried to removeListener on something that wasn\'t a listener' );
    }
    this.guardListeners();
    this.listeners.delete( listener );

    this.changeCount && this.changeCount( -1 );
  }

  /**
   * Removes all the listeners
   * @public
   */
  removeAllListeners() {

    const size = this.listeners.size;

    this.guardListeners();
    this.listeners.clear();

    this.changeCount && this.changeCount( -size );
  }

  /**
   * If listeners are added/removed while emit() is in progress, we must make a defensive copy of the array of listeners
   * before changing the array, and use it for the rest of the notifications until the emit call has completed.
   * @private
   */
  guardListeners() {

    for ( let i = this.emitContexts.length - 1; i >= 0; i-- ) {

      // Once we meet a level that was already guarded, we can stop, since all previous levels were already guarded
      if ( this.emitContexts[ i ].listenerArray ) {
        break;
      }
      else {

        // Mark copies as 'guarded' so that it will use the original listeners when emit started and not the modified
        // list.
        this.emitContexts[ i ].listenerArray = Array.from( this.listeners );
      }
    }
  }

  /**
   * Checks whether a listener is registered with this Emitter
   * @param {function} listener
   * @returns {boolean}
   * @public
   */
  hasListener( listener ) {
    assert && assert( arguments.length === 1, 'Emitter.hasListener should be called with 1 argument' );
    return this.listeners.has( listener );
  }

  /**
   * Returns true if there are any listeners.
   * @returns {boolean}
   * @public
   */
  hasListeners() {
    assert && assert( arguments.length === 0, 'Emitter.hasListeners should be called without arguments' );
    return this.listeners.size > 0;
  }

  /**
   * Returns the number of listeners.
   * @returns {number}
   * @public
   */
  getListenerCount() {
    return this.listeners.size;
  }
}

axon.register( 'TinyEmitter', TinyEmitter );
/* harmony default export */ var js_TinyEmitter = (TinyEmitter);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/Timer.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Timer so that other modules can run timing related code through the simulation's requestAnimationFrame. Use its
 * Emitter interface for adding/removing listeners.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */




class Timer_Timer extends js_TinyEmitter {

  /**
   * Adds a listener to be called back once after the specified time in milliseconds
   * @param {function} listener - called with no arguments
   * @param {number} timeout in milliseconds
   * @returns {function} an internally-wrapped listener which can be removed with clearTimeout
   * @public
   */
  setTimeout( listener, timeout ) { // eslint-disable-line bad-sim-text
    let elapsed = 0;
    const callback = dt => {
      elapsed += dt;

      // Convert seconds to ms and see if item has timed out
      if ( elapsed * 1000 >= timeout ) {

        // make sure that this callback hasn't already been removed by another listener while emit() is in progress
        if ( this.hasListener( callback ) ) {
          listener();
          this.removeListener( callback );
        }
      }
    };
    this.addListener( callback );

    // Return the callback so it can be removed with removeStepListener
    return callback;
  }

  /**
   * Clear a scheduled timeout. If there was no timeout, nothing is done.
   * @param {function} listener
   * @public
   */
  clearTimeout( listener ) {
    if ( this.hasListener( listener ) ) {
      this.removeListener( listener );
    }
  }

  /**
   * Adds a listener to be called at specified intervals (in milliseconds)
   * @param {function} listener - called with no arguments
   * @param {number} interval - in milliseconds
   * @returns {function} an internally-wrapped listener which can be removed with clearInterval
   * @public
   */
  setInterval( listener, interval ) { // eslint-disable-line bad-sim-text
    let elapsed = 0;
    const callback = dt => {
      elapsed += dt;

      // Convert seconds to ms and see if item has timed out
      while ( elapsed * 1000 >= interval && this.hasListener( callback ) !== -1 ) {
        listener();
        elapsed = elapsed - interval / 1000.0; // Save the leftover time so it won't accumulate
      }
    };
    this.addListener( callback );

    // Return the callback so it can be removed with removeListener
    return callback;
  }

  /**
   * Clear a scheduled interval. If there was no interval, nothing is done.
   * @param {function} listener
   * @public
   */
  clearInterval( listener ) {
    if ( this.hasListener( listener ) ) {
      this.removeListener( listener );
    }
  }

  /**
   * Run a callback on the next frame. This method is largely for clarity.
   * @public
   * @param {function()} listener
   */
  runOnNextTick( listener ) {
    this.setTimeout( listener, 0 );
  }
}

axon.register( 'Timer', Timer_Timer );
/* harmony default export */ var js_Timer = (Timer_Timer);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/animationFrameTimer.js
// Copyright 2020, University of Colorado Boulder




// Like stepTimer but runs every frame whether the sim is active or not.
const animationFrameTimer = new js_Timer( { parameters: [ { valueType: 'number' } ] } );

axon.register( 'animationFrameTimer', animationFrameTimer );
/* harmony default export */ var js_animationFrameTimer = (animationFrameTimer);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/arrayRemove.js
// Copyright 2014-2020, University of Colorado Boulder

/**
 * Removes a single (the first) matching object from an Array.
 *
 * @author Jonathan Olson <jonathan.olson@colorado.edu>
 */



/*
 * @param {Array} array
 * @param {*} item - the item to remove from the array
 */
function arrayRemove( array, item ) {
  assert && assert( Array.isArray( array ), 'arrayRemove takes an Array' );

  const index = _.indexOf( array, item );
  assert && assert( index >= 0, 'item not found in Array' );

  array.splice( index, 1 );
}

js_phetCore.register( 'arrayRemove', arrayRemove );

/* harmony default export */ var js_arrayRemove = (arrayRemove);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/EnumerationIO.js
// Copyright 2018-2020, University of Colorado Boulder

/**
 * IO Type for phet-core Enumeration that supports serializing and deserializing values. Cannot be moved to the core
 * type since Enumeration must be defined before ValidatorDef can be defined.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */





// {Map.<enumeration:Enumeration, IOType>} - Cache each parameterized EnumerationIO so that it is only created once.
const EnumerationIO_cache = new Map();

/**
 * This caching implementation should be kept in sync with the other parametric IO Type caching implementations.
 * @param {Enumeration} enumeration
 * @returns {IOType}
 */
const EnumerationIO = enumeration => {
  assert && assert( enumeration, 'enumeration must be supplied' );
  assert && assert( enumeration instanceof js_Enumeration, 'enumeration must be an Enumeration' );

  if ( !EnumerationIO_cache.has( enumeration ) ) {
    const toStateObjectImpl = v => v.name;
    const valueNames = enumeration.VALUES.map( toStateObjectImpl );

    // Enumeration supports additional documentation, so the values can be described.
    const additionalDocs = enumeration.phetioDocumentation ? ` ${enumeration.phetioDocumentation}` : '';

    EnumerationIO_cache.set( enumeration, new types_IOType( `EnumerationIO(${valueNames.join( '|' )})`, {
      valueType: enumeration,
      documentation: `Possible values: ${valueNames}.${additionalDocs}`,
      toStateObject: value => toStateObjectImpl( value ),
      fromStateObject: stateObject => {
        assert && assert( typeof stateObject === 'string', 'unsupported EnumerationIO value type, expected string' );
        assert && assert( enumeration.KEYS.indexOf( stateObject ) >= 0, `Unrecognized value: ${stateObject}` );
        return enumeration[ stateObject ];
      }
    } ) );
  }

  return EnumerationIO_cache.get( enumeration );
};

js_phetCore.register( 'EnumerationIO', EnumerationIO );
/* harmony default export */ var js_EnumerationIO = (EnumerationIO);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/EventType.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * This characterizes events that may be emitted from PhetioObjects to the PhET-iO data stream.
 *
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */





const EventType_EventType = js_Enumeration.byKeys( [

  // The user has taken an action, such as pressing a button or moving a mouse
  'USER',

  // An event was produced by the simulation model. This could be in response to a user event, or something that happens
  // during the simulation step. Note the separation is not model vs view, but user-driven vs automatic.
  'MODEL',

  // An event was triggered by the PhET-iO wrapper, via PhetioEngineIO.triggerEvent
  'WRAPPER',

  // These messages are suppressed, use this to opt a PhetioObject out of the data stream feature.
  'OPT_OUT'
], {
  beforeFreeze: EventType => {
    EventType.phetioType = js_EnumerationIO( EventType );
  }
} );

tandemNamespace.register( 'EventType', EventType_EventType );
/* harmony default export */ var js_EventType = (EventType_EventType);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/Tandem.js
// Copyright 2015-2020, University of Colorado Boulder

/**
 * Tandem defines a set of trees that are used to assign unique identifiers to PhetioObjects in PhET simulations and
 * notify listeners when the associated PhetioObjects have been added/removed. It is used to support PhET-iO.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */





// constants
// Tandem can't depend on joist, so cannot use packageJSON module
const packageJSON = _.hasIn( window, 'phet.chipper.packageObject' ) ? phet.chipper.packageObject : { name: 'placeholder' };

const PHET_IO_ENABLED = _.hasIn( window, 'phet.preloads.phetio' );
const PRINT_MISSING_TANDEMS = PHET_IO_ENABLED && phet.preloads.phetio.queryParameters.phetioPrintMissingTandems;

// Validation defaults to true, but can be overridden to be false in package.json.
const IS_VALIDATION_DEFAULT = _.hasIn( packageJSON, 'phet.phet-io.validation' ) ? packageJSON.phet[ 'phet-io' ].validation : true;

// The default value for validation can be overridden with a query parameter ?phetioValidation={true|false}.
const IS_VALIDATION_QUERY_PARAMETER_SPECIFIED = window.QueryStringMachine && QueryStringMachine.containsKey( 'phetioValidation' );
const IS_VALIDATION_SPECIFIED = ( PHET_IO_ENABLED && IS_VALIDATION_QUERY_PARAMETER_SPECIFIED ) ? phet.preloads.phetio.queryParameters.phetioValidation :
                                ( PHET_IO_ENABLED && IS_VALIDATION_DEFAULT );

const VALIDATION = PHET_IO_ENABLED && IS_VALIDATION_SPECIFIED && !PRINT_MISSING_TANDEMS;

const REQUIRED_TANDEM_NAME = 'requiredTandem';
const OPTIONAL_TANDEM_NAME = 'optionalTandem';

// used to keep track of missing tandems.  Each element has type {{phetioID:{string}, stack:{string}}
const missingTandems = {
  required: [],
  optional: []
};

// Listeners that will be notified when items are registered/deregistered. See doc in addPhetioObjectListener
const phetioObjectListeners = [];

// {PhetioObject[]} - PhetioObjects that have been added before listeners are ready.
const bufferedPhetioObjects = [];

class Tandem_Tandem {

  /**
   * Typically, sims will create tandems using `tandem.createTandem`.  This constructor is used internally or when
   * a tandem must be created from scratch.
   *
   * @param {Tandem|null} parentTandem - parent for a child tandem, or null for a root tandem
   * @param {string} name - component name for this level, like 'resetAllButton'
   * @param {Object} [options]
   */
  constructor( parentTandem, name, options ) {
    assert && assert( parentTandem === null || parentTandem instanceof Tandem_Tandem, 'parentTandem should be null or Tandem' );
    assert && assert( typeof name === 'string', 'name must be defined' );
    assert && assert( this.getTermRegex().test( name ), `name should match the regex pattern: ${name}` );

    // @public (read-only) {Tandem|null}
    this.parentTandem = parentTandem;

    // @public (read-only) - the last part of the tandem (after the last .), used e.g., in Joist for creating button
    // names dynamically based on screen names
    this.name = name;

    // @public (read-only)
    this.phetioID = this.parentTandem ? window.phetio.PhetioIDUtils.append( this.parentTandem.phetioID, this.name )
                                      : this.name;

    // options (even subtype options) must be stored so they can be passed through to children
    // Note: Make sure that added options here are also added to options for inheritance and/or for composition
    // (createTandem/parentTandem/getExtendedOptions) as appropriate.
    options = js_merge( {

      // required === false means it is an optional tandem
      required: true,

      // if the tandem is required but not supplied, an error will be thrown.
      supplied: true
    }, options );

    // @private {Object.<string, Tandem>}
    this.children = {};

    if ( this.parentTandem ) {
      assert && assert( !this.parentTandem.hasChild( name ), `parent should not have child: ${name}` );
      this.parentTandem.addChild( name, this );
    }

    // @private
    this.required = options.required;

    // @public (read-only)
    this.supplied = options.supplied;
  }

  /**
   * Returns the regular expression which can be used to test each term. The term must consist only of alpha-numeric
   * characters or tildes.
   * @returns {RegExp}
   * @protected
   */
  getTermRegex() {
    return /^[a-zA-Z0-9[\],]+$/;
  }

  /**
   * If the provided tandem is not supplied, support the ?printMissingTandems query parameter for extra logging during
   * initial instrumentation.
   * @public
   * @param tandem
   */
  static onMissingTandem( tandem ) {
    assert && assert( tandem instanceof Tandem_Tandem );

    // When the query parameter phetioPrintMissingTandems is true, report tandems that are required but not supplied
    if ( PRINT_MISSING_TANDEMS && !tandem.supplied ) {
      const stackTrace = new Error().stack;
      if ( tandem.required ) {
        missingTandems.required.push( { phetioID: this.phetioID, stack: stackTrace } );
      }
      else {

        // When the query parameter phetioPrintMissingTandems is true, report tandems that are optional but not
        // supplied, but not for Fonts because they are too numerous.
        if ( stackTrace.indexOf( 'Font' ) === -1 ) {
          missingTandems.optional.push( { phetioID: this.phetioID, stack: stackTrace } );
        }
      }
    }
  }

  /**
   * Adds a PhetioObject.  For example, it could be an axon Property, SCENERY/Node or SUN/RoundPushButton.
   * phetioEngine listens for when PhetioObjects are added and removed to keep track of them for PhET-iO.
   * @param {PhetioObject} phetioObject
   * @public
   */
  addPhetioObject( phetioObject ) {
    assert && assert( arguments.length === 1, 'Tandem.addPhetioObject takes one argument' );

    // Cannot use typical require statement for PhetioObject because it creates a module loading loop
    assert && assert( phetioObject instanceof tandemNamespace.PhetioObject, 'argument should be of type PhetioObject' );

    if ( PHET_IO_ENABLED ) {

      // Throw an error if the tandem is required but not supplied
      assert && Tandem_Tandem.VALIDATION && assert( !( this.required && !this.supplied ), 'Tandem was required but not supplied' );

      // If tandem is optional and not supplied, then ignore it.
      if ( !this.required && !this.supplied ) {

        // Optionally instrumented types without tandems are not added.
        return;
      }

      if ( !Tandem_Tandem.launched ) {
        bufferedPhetioObjects.push( phetioObject );
      }
      else {
        for ( let i = 0; i < phetioObjectListeners.length; i++ ) {
          phetioObjectListeners[ i ].addPhetioObject( phetioObject );
        }
      }
    }
  }

  /**
   * Returns true if this Tandem has the specified ancestor Tandem.
   * @param {Tandem} ancestor
   * @returns {boolean}
   * @public
   */
  hasAncestor( ancestor ) {
    return this.parentTandem === ancestor || ( this.parentTandem && this.parentTandem.hasAncestor( ancestor ) );
  }

  /**
   * Removes a PhetioObject and signifies to listeners that it has been removed.
   * @param {PhetioObject} phetioObject
   * @public
   */
  removePhetioObject( phetioObject ) {

    if ( !this.required && !this.supplied ) {
      return;
    }

    // Only active when running as phet-io
    if ( PHET_IO_ENABLED ) {
      if ( !Tandem_Tandem.launched ) {
        assert && assert( bufferedPhetioObjects.indexOf( phetioObject ) >= 0, 'should contain item' );
        js_arrayRemove( bufferedPhetioObjects, phetioObject );
      }
      else {
        for ( let i = 0; i < phetioObjectListeners.length; i++ ) {
          phetioObjectListeners[ i ].removePhetioObject( phetioObject );
        }
      }
    }

    phetioObject.tandem.dispose();
  }

  /**
   * Used for creating new tandems, extends this Tandem's options with the passed-in options.
   * @param {Object} [options]
   * @returns {Object} -extended options
   * @public
   */
  getExtendedOptions( options ) {

    // Any child of something should be passed all inherited options. Make sure that this extend call includes all
    // that make sense from the constructor's extend call.
    return js_merge( {
      supplied: this.supplied,
      required: this.required
    }, options );
  }

  /**
   * Create a new Tandem by appending the given id, or if the child Tandem already exists, return it instead.
   * @param {string} name
   * @param {Object} [options]
   * @returns {Tandem}
   * @public
   */
  createTandem( name, options ) {

    options = this.getExtendedOptions( options );

    // re-use the child if it already exists, but make sure it behaves the same.
    if ( this.hasChild( name ) ) {
      const currentChild = this.children[ name ];
      assert && assert( currentChild.required === options.required );
      assert && assert( currentChild.supplied === options.supplied );
      assert && assert( currentChild instanceof Tandem_Tandem );
      return currentChild;
    }
    else {
      return new Tandem_Tandem( this, name, options );
    }
  }

  /**
   * @param {string} name
   * @returns {boolean}
   * @private
   */
  hasChild( name ) {
    return this.children.hasOwnProperty( name );
  }

  /**
   * @param {string} name
   * @param {Tandem} tandem
   * @public
   */
  addChild( name, tandem ) {
    assert && assert( !this.hasChild( name ) );
    this.children[ name ] = tandem;
  }

  /**
   * Fire a callback on all descendants of this Tandem
   * @param {function(Tandem)} callback
   * @public
   */
  iterateDescendants( callback ) {
    for ( const childName in this.children ) {
      if ( this.children.hasOwnProperty( childName ) ) {
        callback( this.children[ childName ] );
        this.children[ childName ].iterateDescendants( callback );
      }
    }
  }

  /**
   * @param {string} childName
   * @private
   */
  removeChild( childName ) {
    assert && assert( this.hasChild( childName ) );
    delete this.children[ childName ];
  }

  /**
   * @private
   */
  dispose() {
    this.parentTandem.removeChild( this.name );
  }

  /**
   * For API validation, each PhetioObject has a corresponding concrete PhetioObject for comparison. Non-dynamic
   * PhetioObjects have the trivial case where its archetypal phetioID is the same as its phetioID.
   * @returns {string}
   * @public
   */
  getArchetypalPhetioID() {

    // Dynamic elements always have a parent container, hence since this does not have a parent, it must already be concrete
    return this.parentTandem ? window.phetio.PhetioIDUtils.append( this.parentTandem.getArchetypalPhetioID(), this.name ) : this.phetioID;
  }

  /**
   * Creates a group tandem for creating multiple indexed child tandems, such as:
   * sim.screen.model.electron0
   * sim.screen.model.electron1
   *
   * In this case, 'sim.screen.model.electron' is the string passed to createGroupTandem.
   *
   * Used for arrays, observable arrays, or when many elements of the same type are created and they do not otherwise
   * have unique identifiers.
   * @param {string} name
   * @returns {GroupTandem}
   * @public
   */
  createGroupTandem( name ) {
    if ( this.children[ name ] ) {
      return this.children[ name ];
    }
    return new GroupTandem( this, name );
  }

  /**
   * Adds a listener that will be notified when items are registered/deregistered
   * Listeners have the form
   * {
   *   addPhetioObject(id,phetioObject),
   *   removePhetioObject(id,phetioObject)
   * }
   * where id is of type {string} and phetioObject is of type {PhetioObject}
   *
   * @param {Object} phetioObjectListener - described above
   * @public
   * @static
   */
  static addPhetioObjectListener( phetioObjectListener ) {
    phetioObjectListeners.push( phetioObjectListener );
  }

  /**
   * After all listeners have been added, then Tandem can be launched.  This registers all of the buffered PhetioObjects
   * and subsequent PhetioObjects will be registered directly.
   * @public (phetioEngine PhetioObjectTests)
   * @static
   */
  static launch() {
    assert && assert( !Tandem_Tandem.launched, 'Tandem cannot be launched twice' );
    Tandem_Tandem.launched = true;
    while ( bufferedPhetioObjects.length > 0 ) {
      const phetioObject = bufferedPhetioObjects.shift();
      phetioObject.tandem.addPhetioObject( phetioObject );
    }
    assert && assert( bufferedPhetioObjects.length === 0, 'bufferedPhetioObjects should be empty' );
  }

  /**
   * ONLY FOR TESTING!!!!
   * This was created to "undo" launch so that tests can better expose cases around calling Tandem.launch()
   * @public (tests only)
   */
  static unlaunch() {
    Tandem_Tandem.launched = false;
    bufferedPhetioObjects.length = 0;
  }
}

// @public (read-only) - a list of PhetioObjects ready to be sent out to listeners, but can't because Tandem hasn't been
// launched yet.
Tandem_Tandem.bufferedPhetioObjects = bufferedPhetioObjects;

class RootTandem extends Tandem_Tandem {

  /**
   * RootTandems only accept specifically named children.
   * @override
   * @param {string} name
   * @param {Object} [options]
   * @returns {Tandem}
   * @public
   */
  createTandem( name, options ) {
    if ( Tandem_Tandem.VALIDATION ) {
      const allowedOnRoot = name === window.phetio.PhetioIDUtils.GLOBAL_COMPONENT_NAME ||
                            name === REQUIRED_TANDEM_NAME ||
                            name === OPTIONAL_TANDEM_NAME ||
                            name === window.phetio.PhetioIDUtils.GENERAL_COMPONENT_NAME ||
                            _.endsWith( name, 'Screen' );
      assert && assert( allowedOnRoot, `tandem name not allowed on root: "${name}"; perhaps try putting it under general or global` );
    }

    return super.createTandem( name, options );
  }
}

// The next few statics are created outside the static block because they instantiate Tandem instances.

/**
 * The root tandem for a simulation
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.ROOT = new RootTandem( null, _.camelCase( packageJSON.name ) );

/**
 * Many simulation elements are nested under "general". This tandem is for elements that exists in all sims. For a
 * place to put simulation specific globals, see `Tandem.GLOBAL`
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GENERAL = Tandem_Tandem.ROOT.createTandem( window.phetio.PhetioIDUtils.GENERAL_COMPONENT_NAME );

/**
 * Tandem for model simulation elements that are general to all sims.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GENERAL_MODEL = Tandem_Tandem.GENERAL.createTandem( window.phetio.PhetioIDUtils.MODEL_COMPONENT_NAME );

/**
 * Tandem for view simulation elements that are general to all sims.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GENERAL_VIEW = Tandem_Tandem.GENERAL.createTandem( window.phetio.PhetioIDUtils.VIEW_COMPONENT_NAME );

/**
 * Tandem for controller simulation elements that are general to all sims.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GENERAL_CONTROLLER = Tandem_Tandem.GENERAL.createTandem( window.phetio.PhetioIDUtils.CONTROLLER_COMPONENT_NAME );

/**
 * Simulation elements that don't belong in screens should be nested under "global". Note that this tandem should only
 * have simulation specific elements in them. Instrument items used by all sims under `Tandem.GENERAL`. Most
 * likely simulations elements should not be directly under this, but instead either under the model or view sub
 * tandems.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GLOBAL = Tandem_Tandem.ROOT.createTandem( window.phetio.PhetioIDUtils.GLOBAL_COMPONENT_NAME );

/**
 * Model simulation elements that don't belong in specific screens should be nested under this Tandem. Note that this
 * tandem should only have simulation specific elements in them.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GLOBAL_MODEL = Tandem_Tandem.GLOBAL.createTandem( window.phetio.PhetioIDUtils.MODEL_COMPONENT_NAME );

/**
 * View simulation elements that don't belong in specific screens should be nested under this Tandem. Note that this
 * tandem should only have simulation specific elements in them.
 *
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.GLOBAL_VIEW = Tandem_Tandem.GLOBAL.createTandem( window.phetio.PhetioIDUtils.VIEW_COMPONENT_NAME );

/**
 * Used to indicate a common code component that supports tandem, but doesn't not require it.  If a tandem is not
 * passed in, then it will not be instrumented.
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.OPTIONAL = Tandem_Tandem.ROOT.createTandem( OPTIONAL_TANDEM_NAME, {
  required: false,
  supplied: false
} );

/**
 * To be used exclusively to opt out of situations where a tandem is required.
 * See https://github.com/phetsims/tandem/issues/97.
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.OPT_OUT = Tandem_Tandem.OPTIONAL;

/**
 * Some common code (such as Checkbox or RadioButton) must always be instrumented.
 * @public
 * @constant
 * @type {Tandem}
 */
Tandem_Tandem.REQUIRED = Tandem_Tandem.ROOT.createTandem( REQUIRED_TANDEM_NAME, {

  // let phetioPrintMissingTandems bypass this
  required: VALIDATION || PRINT_MISSING_TANDEMS,
  supplied: false
} );

/**
 * Expose collected missing tandems only populated from specific query parameter, see phetioPrintMissingTandems
 * @public (phet-io internal)
 * @type {Object}
 */
Tandem_Tandem.missingTandems = missingTandems;

/**
 * If PhET-iO is enabled in this runtime.
 * @public
 * @type {boolean}
 */
Tandem_Tandem.PHET_IO_ENABLED = PHET_IO_ENABLED;

/**
 * If PhET-iO is running with validation enabled.
 * @public
 * @type {boolean}
 */
Tandem_Tandem.VALIDATION = VALIDATION;

/**
 * Group Tandem -- Declared in the same file to avoid circular reference errors in module loading.
 */
class GroupTandem extends Tandem_Tandem {

  /**
   * @param {Tandem} parentTandem
   * @param {string} name
   * @constructor
   * @private create with Tandem.createGroupTandem
   */
  constructor( parentTandem, name ) {
    super( parentTandem, name );

    // @private
    this.groupName = name;

    // @private for generating indices from a pool
    this.groupMemberIndex = 0;
  }

  /**
   * Creates the next tandem in the group.
   * @returns {Tandem}
   * @public
   */
  createNextTandem() {
    const tandem = this.parentTandem.createTandem( `${this.groupName}${this.groupMemberIndex}` );
    this.groupMemberIndex++;
    return tandem;
  }
}

// @public (read-only) Before listeners are wired up, tandems are buffered.  When listeners are wired up,
// Tandem.launch() is called and buffered tandems are flushed, then subsequent tandems are delivered to listeners
// directly
Tandem_Tandem.launched = false;

tandemNamespace.register( 'Tandem', Tandem_Tandem );
/* harmony default export */ var js_Tandem = (Tandem_Tandem);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/LinkedElementIO.js
// Copyright 2018-2020, University of Colorado Boulder

/**
 * IO Type for LinkedElement
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */





const LinkedElementIO = new types_IOType( 'LinkedElementIO', {
  isValidValue: () => true,
  documentation: 'A LinkedElement',
  toStateObject: linkedElement => {
    assert && js_Tandem.VALIDATION && assert( linkedElement.element.isPhetioInstrumented(), 'Linked elements must be instrumented' );
    return { elementID: linkedElement.element.tandem.phetioID };
  },
  fromStateObject: stateObject => ( {} )
} );

tandemNamespace.register( 'LinkedElementIO', LinkedElementIO );
/* harmony default export */ var js_LinkedElementIO = (LinkedElementIO);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/phet-core/js/copyWithSortedKeys.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Preload file that sorts the keys in an object intended for JSON, using the strategy defined in
 * https://stackoverflow.com/questions/5467129/sort-javascript-object-by-key
 *
 * This is used in the simulation side to make sure the elements-baseline file is sorted, and used in the phet-io
 * wrapper side to make sure the elements-overrides file is sorted.
 *
 * Namespacing and naming are discussed in https://github.com/phetsims/phet-io/issues/1446#issuecomment-476842068 and below
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */


/**
 * Creates a new object, recursively, by sorting the keys at each level.
 * @param {Object} unordered - jsonifiable object to be sorted by key name.  Sorting is recursive and hence.
 */
const copyWithSortedKeys = unordered => {
  if ( Array.isArray( unordered ) ) {
    return unordered.map( copyWithSortedKeys );
  }
  else if ( typeof unordered !== 'object' || unordered === null ) {
    return unordered;
  }

  const ordered = {};
  Object.keys( unordered ).sort().forEach( key => {
    const value = unordered[ key ];
    ordered[ key ] = copyWithSortedKeys( value );
  } );
  return ordered;
};

js_phetCore.register( 'copyWithSortedKeys', copyWithSortedKeys );

/* harmony default export */ var js_copyWithSortedKeys = (copyWithSortedKeys);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/DynamicTandem.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * A tandem for a dynamic element that stores the name of the archetype that defines its dynamic element's schema.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Chris Klusendorf (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */




// constants
const DYNAMIC_ARCHETYPE_NAME = 'archetype';

class DynamicTandem_DynamicTandem extends js_Tandem {

  /**
   * @param {Tandem} parentTandem
   * @param {string} name
   * @param {Object} [options]
   */
  constructor( parentTandem, name, options ) {
    assert && assert( parentTandem, 'DynamicTandem must have a parentTandem' );
    super( parentTandem, name, options );
  }

  /**
   * Returns the regular expression which can be used to test each term. The term must consist only of alpha-numeric
   * characters or underscores.
   * @returns {RegExp}
   * @protected
   * @override
   */
  getTermRegex() {
    return /^[a-zA-Z0-9_]+$/;
  }

  /**
   * See Tandem.getArchetypalPhetioID, in this case, look up the corresponding archetype.
   * A dynamic phetioID contains text like .................'sim.screen1.particles.particles_7.visibleProperty'
   * This method looks up the corresponding archetype like..'sim.screen1.particles.archetype.visibleProperty'
   * @returns {string}
   * @public
   * @override
   */
  getArchetypalPhetioID() {
    assert && assert( this.parentTandem, 'Group elements must be in a Group' );
    return window.phetio.PhetioIDUtils.append( this.parentTandem.getArchetypalPhetioID(), DYNAMIC_ARCHETYPE_NAME );
  }
}

// @public {string}
DynamicTandem_DynamicTandem.DYNAMIC_ARCHETYPE_NAME = DYNAMIC_ARCHETYPE_NAME;

tandemNamespace.register( 'DynamicTandem', DynamicTandem_DynamicTandem );
/* harmony default export */ var js_DynamicTandem = (DynamicTandem_DynamicTandem);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/phetioAPIValidation.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * This singleton is responsible for ensuring that the phet-io api is correct through the lifetime of the simulation.
 * The phet-io api is defined through multiple preloaded files. The "elements baseline" file holds an exact match of
 * what PhetioObject instances/metadata the sim should create on startup, where the "elements overrides" file is a
 * sparse list that can overwrite metadata without changing the code. See `grunt generate-phet-io-api` for
 * more information. The complete list of checks was decided on in https://github.com/phetsims/phet-io/issues/1453 and
 * is as follows:
 *
 * 1. A full schema is required - any phet-io brand sim without these will have a 404, but this rule isn't tested in this file.
 * 2. Registered PhetioObject baseline must equal baseline schema to ensure that baseline changes are intentional.
 * 3. ~~ is no more
 * 4. After startup, only dynamic instances prescribed by the baseline file can be registered.
 * 5. When the sim is finished starting up, all non-dynamic schema entries must be registered.
 * 6. Any static, registered PhetioObject can never be deregistered.
 * 7. Any schema entries in the overrides file must exist in the baseline file
 * 8. Any schema entries in the overrides file must be different from its baseline counterpart
 * 9. Types in the sim must exactly match types in the types file to ensure that type changes are intentional.
 * 10. Dynamic elements should not appear in the API.
 * 11. Dynamic element metadata should match the archetype in the API.
 *
 * Terminology:
 * schema: specified through preloads. The full schema is the baseline plus the overrides, but those parts can be
 *         referred to separately.
 * registered: the process of instrumenting a PhetioObject and it "becoming" a PhET-iO Element on the wrapper side.
 * static PhetioObject: A registered PhetioObject that exists for the lifetime of the sim. It should not be removed
 *                      (even intermittently) and must be created during startup so that it is immediately interoperable.
 * dynamic PhetioObject: A registered PhetioObject that can be created and/or destroyed at any point. Only dynamic
 *                       PhetioObjects can be created after startup.
 *
 * See https://github.com/phetsims/phet-io/issues/1443#issuecomment-484306552 for an explanation of how to maintain the
 * PhET-iO API for a simulation.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Chris Klusendorf (PhET Interactive Simulations)
 */






// constants
// The api-tracked and validated metadata keys
const KEYS_TO_CHECK = [
  'phetioDynamicElement',
  'phetioEventType',
  'phetioIsArchetype',
  'phetioPlayback',
  'phetioReadOnly',
  'phetioState',
  'phetioTypeName'
];

class phetioAPIValidation_PhetioAPIValidation {

  constructor() {

    /**
     * {Object[]} - Each object holds a single "api mismatch" with the following keys:
     *                phetioID: {string}
     *                stack: {string} - for a stack trace
     *                ruleInViolation: {string} - one of the numbered list in the header doc.
     *                [message]: {string} - specific problem
     *
     * Feel free to add any other JSONifyable keys to this to make the error more clear! All mismatches are printed
     * at once for clarity, see PhetioEngine.
     * @private
     */
    this.apiMismatches = [];

    // @private - keep track of when the sim has started.
    this.simHasStarted = false;

    // @public {boolean} - settable by phetioAPITest.js. Validation is only enabled when all screens are present.
    this.enabled = assert && js_Tandem.VALIDATION;

    // @private (read-only) {string}
    this.referenceAPI = this.enabled && window.phet.preloads.phetio.queryParameters.phetioReferenceAPI;

    // @private {Object.<typeName:string, IOType>} - this must be all phet-io types so that the
    // following would fail: add a phetioType, then remove it, then add a different one under the same typeName.
    // A Note about memory: Every IOType that is loaded as a module is already loaded on the namespace. Therefore
    // this map doesn't add any memory by storing these. The exception to this is parametric IOTypes. It should be
    // double checked that anything being passed into a parametric type is memory safe. As of this writing, only IOTypes
    // are passed to parametric IOTypes, so this pattern remains memory leak free. Furthermore, this list is only
    // populated when `this.enabled`.
    this.everyPhetioType = {};

    // @private {Object|null} if defined, this is the API loaded from a generated API file
    this.loadedReferenceAPI = null;

    if ( this.enabled && this.referenceAPI ) {
      assert && assert( phet.preloads.phetio.createArchetypes, 'archetypes are required to be created to validate' );

      // See readFile.js
      const xhr = new XMLHttpRequest();
      xhr.open( 'GET', window.phet.preloads.phetio.queryParameters.phetioReferenceAPI );
      xhr.send( null );
      xhr.onreadystatechange = () => {
        if ( xhr.readyState === 4 /*done*/ && xhr.status === 200 /*ok*/ ) {
          this.loadedReferenceAPI = JSON.parse( xhr.responseText );
        }
      };
    }
  }

  /**
   * Callback when the simulation is ready to go, and all static PhetioObjects have been created.
   * @param {PhetioEngine} phetioEngine
   * @public
   */
  onSimStarted( phetioEngine ) {

    this.simHasStarted = true;

    if ( this.enabled && phet.joist.sim.allScreensCreated ) {
      this.validateOverridesFile();

      if ( this.referenceAPI ) {

        assert && assert( this.loadedReferenceAPI, 'Expected a reference API but it was not loaded: ' + this.loadedReferenceAPI );

        const desiredMetadata = this.loadedReferenceAPI.phetioElements;
        const desiredTypes = this.loadedReferenceAPI.phetioTypes;

        const actualMetadata = phetioEngine.getPhetioElementsMetadata();
        const actualTypes = phetioEngine.getPhetioTypes();

        // check to make sure all phet-io elements and type entries were used.  If an entry wasn't used, throw an
        // assertion error because the sim is missing something it is supposed to have.
        // Don't check for this when generating the API file from the code.
        for ( const phetioID in desiredMetadata ) {
          if ( desiredMetadata.hasOwnProperty( phetioID ) ) {
            if ( desiredMetadata[ phetioID ].phetioDynamicElement ) {
              this.assertAPIError( {
                phetioID: phetioID,
                ruleInViolation: '10. Dynamic elements should not appear in the API.',
                message: 'dynamic phetioID not expected but found'
              } );
            }
            if ( !actualMetadata.hasOwnProperty( phetioID ) ) {
              this.assertAPIError( {
                phetioID: phetioID,
                ruleInViolation: '5. When the sim is finished starting up, all non-dynamic schema entries must be registered.',
                message: 'phetioID expected but does not exist'
              } );
            }

            // Compare PhET-iO Elements for compatibility
            for ( let i = 0; i < KEYS_TO_CHECK.length; i++ ) {
              const key = KEYS_TO_CHECK[ i ];
              if ( desiredMetadata[ phetioID ][ key ] !== actualMetadata[ phetioID ][ key ] ) {
                this.assertAPIError( {
                  ruleInViolation: '2. Registered PhetioObject baseline must equal baseline schema to ensure that baseline changes are intentional.',
                  phetioID: phetioID,
                  message: `Incompatible value for ${key}, desired=${desiredMetadata[ phetioID ][ key ]}, actual=${actualMetadata[ phetioID ][ key ]}`
                } );
              }
            }
          }
        }

        // Compare IO Types for compatibility
        for ( const type in desiredTypes ) {
          if ( desiredTypes.hasOwnProperty( type ) ) {

            // make sure we have the desired type
            if ( !actualTypes.hasOwnProperty( type ) ) {
              this.assertAPIError( {
                ruleInViolation: 'Desired type missing: ' + type.typeName
              } );
            }
            else {

              // make sure we have all of the methods
              const desiredMethods = desiredTypes[ type ].methods;
              const actualMethods = actualTypes[ type ].methods;
              for ( const method in desiredMethods ) {
                if ( !actualMethods.hasOwnProperty( method ) ) {
                  this.assertAPIError( { ruleInViolation: `Missing method, type=${type}, method=${method}` } );
                }
              }
            }
          }
        }

        if ( window.phet.preloads.phetio.queryParameters.phetioReferenceAPIValidationLevel === 'exact' ) {

          if ( !_.isEqual( desiredMetadata, actualMetadata ) ) {
            this.assertAPIError( {
              // Note: this breaks rule 2 which may in some cases be rule 3
              ruleInViolation: '2. Registered PhetioObject baseline must equal baseline schema to ensure that baseline changes are intentional.',
              message: 'baseline schema does not match PhetioObject computed baseline metadata',
              phetioElementsBaseline: desiredMetadata,
              stringifiedBaseline: JSON.stringify( js_copyWithSortedKeys( desiredMetadata ), null, 2 ),
              phetioElementsBaselineFromFile: desiredMetadata
            } );
          }

          if ( !_.isEqual( desiredTypes, actualTypes ) ) {
            const phetioTypesKeys = Object.keys( desiredTypes );
            const windowPhetioTypesKeys = Object.keys( window.phet.preloads.phetio.phetioTypes );

            this.assertAPIError( {
              ruleInViolation: '9. Types in the sim must exactly match types in the types file to ensure that type changes are intentional.',
              message: 'phetioTypes are not equivalent',
              areKeysEquivalent: _.isEqual( phetioTypesKeys.sort(), windowPhetioTypesKeys.sort() ),
              typesNotInSim: windowPhetioTypesKeys.filter( x => !phetioTypesKeys.includes( x ) ),
              typesNotInFile: phetioTypesKeys.filter( x => !windowPhetioTypesKeys.includes( x ) )
            } );
          }
        }
      }
    }
  }

  /**
   * Checks if a removed phetioObject is part of a Group
   * @param {PhetioObject} phetioObject
   * @public
   */
  onPhetioObjectRemoved( phetioObject ) {
    if ( !this.enabled ) {
      return;
    }

    const phetioID = phetioObject.tandem.phetioID;

    // if it isn't dynamic, then it shouldn't be removed during the lifetime of the sim.
    if ( !phetioObject.phetioDynamicElement ) {
      this.assertAPIError( {
        phetioID: phetioID,
        ruleInViolation: '6. Any static, registered PhetioObject can never be deregistered.'
      } );
    }
  }

  /**
   * Should be called from phetioEngine when a PhetioObject is added to the PhET-iO
   * @param {PhetioObject} phetioObject
   * @public
   */
  onPhetioObjectAdded( phetioObject ) {
    if ( !this.enabled ) {
      return;
    }

    const newPhetioType = phetioObject.phetioType;
    const oldPhetioType = this.everyPhetioType[ newPhetioType.typeName ];

    if ( !oldPhetioType ) { // This may not be necessary, but may be helpful so that we don't overwrite if rule 10 is in violation
      this.everyPhetioType[ newPhetioType.typeName ] = newPhetioType;
    }

    if ( this.simHasStarted ) {

      // Here we need to kick this validation to the next frame to support construction in any order. Parent first, or
      // child first. Use namespace to avoid because timer is a PhetioObject.
      phet.axon.animationFrameTimer.runOnNextTick( () => {

        // The only instances that it's OK to create after startup are "dynamic instances" which are marked as such.
        if ( !phetioObject.phetioDynamicElement ) {
          this.assertAPIError( {
            phetioID: phetioObject.tandem.phetioID,
            ruleInViolation: '4. After startup, only dynamic instances prescribed by the baseline file can be registered.'
          } );
        }
        else {

          // Compare the dynamic element to the archetype in to the loaded reference API, if specified
          const archetypeID = phetioObject.tandem.getArchetypalPhetioID();

          // Compare the dynamic element to the archetype in to the loaded reference API, if specified
          if ( this.loadedReferenceAPI ) {
            checkDynamicInstanceAgainstArchetype( this, phetioObject, this.loadedReferenceAPI.phetioElements[ archetypeID ], 'reference API' );
          }
          if ( phet.preloads.phetio.createArchetypes ) {

            // Compare to the simulation-defined archetype, if it exists
            checkDynamicInstanceAgainstArchetype( this, phetioObject, phet.phetio.phetioEngine.getPhetioObject( archetypeID ).getMetadata(), 'simulation archetype' );
          }
        }
      } );
    }
  }

  /**
   * @private
   */
  validateOverridesFile() {

    // import phetioEngine causes a cycle and cannot be used, hence we must use the namespace
    const entireBaseline = phet.phetio.phetioEngine.getPhetioElementsBaseline();

    for ( const phetioID in window.phet.preloads.phetio.phetioElementsOverrides ) {
      const isArchetype = phetioID.indexOf( js_DynamicTandem.DYNAMIC_ARCHETYPE_NAME ) >= 0;
      if ( !phet.preloads.phetio.createArchetypes && !entireBaseline.hasOwnProperty( phetioID ) ) {
        assert && assert( isArchetype, 'phetioID missing from the baseline that was not an archetype: ' + phetioID );
      }
      else {
        if ( !entireBaseline.hasOwnProperty( phetioID ) ) {
          this.assertAPIError( {
            phetioID: phetioID,
            ruleInViolation: '7. Any schema entries in the overrides file must exist in the baseline file.',
            message: 'phetioID expected in the baseline file but does not exist'
          } );
        }
        else {

          const override = window.phet.preloads.phetio.phetioElementsOverrides[ phetioID ];
          const baseline = entireBaseline[ phetioID ];

          if ( Object.keys( override ).length === 0 ) {
            this.assertAPIError( {
              phetioID: phetioID,
              ruleInViolation: '8. Any schema entries in the overrides file must be different from its baseline counterpart.',
              message: 'no metadata keys found for this override.'
            } );
          }

          for ( const metadataKey in override ) {
            if ( !baseline.hasOwnProperty( metadataKey ) ) {
              this.assertAPIError( {
                phetioID: phetioID,
                ruleInViolation: '8. Any schema entries in the overrides file must be different from its baseline counterpart.',
                message: `phetioID metadata key not found in the baseline: ${metadataKey}`
              } );
            }

            if ( override[ metadataKey ] === baseline[ metadataKey ] ) {
              this.assertAPIError( {
                phetioID: phetioID,
                ruleInViolation: '8. Any schema entries in the overrides file must be different from its baseline counterpart.',
                message: 'phetioID metadata override value is the same as the corresponding metadata value in the baseline.'
              } );
            }
          }
        }
      }
    }
  }

  /**
   * Assert out the failed api validation rule.
   * @param {Object} apiErrorObject - see doc for this.apiMismatches
   * @private
   */
  assertAPIError( apiErrorObject ) {

    const mismatchMessage = apiErrorObject.phetioID ? `${apiErrorObject.phetioID}:  ${apiErrorObject.ruleInViolation}` :
                            `${apiErrorObject.ruleInViolation}`;

    console.log( 'error data:', apiErrorObject );
    assert && assert( false, 'PhET-iO API error:\n' + mismatchMessage );
  }
}

/**
 * Compare a dynamic phetioObject's metadata to the expected metadata
 * @param {phetioAPIValidation} phetioAPIValidation
 * @param {PhetioObject} phetioObject
 * @param {Object} archetypeMetadata - either from a reference API or from an archetype
 * @param {string} source - where the archetype came from, for debugging
 */
const checkDynamicInstanceAgainstArchetype = ( phetioAPIValidation, phetioObject, archetypeMetadata, source ) => {
  const actualMetadata = phetioObject.getMetadata();
  KEYS_TO_CHECK.forEach( key => {

    // These attributes are different for archetype vs actual
    if ( key !== 'phetioDynamicElement' && key !== 'phetioArchetypePhetioID' && key !== 'phetioIsArchetype' ) {

      if ( archetypeMetadata[ key ] !== actualMetadata[ key ] ) {
        phetioAPIValidation.assertAPIError( {
          phetioID: phetioObject.tandem.phetioID,
          ruleInViolation: '11. Dynamic element metadata should match the archetype in the API.',
          source: source,
          message: 'mismatched metadata: ' + key
        } );
      }
    }
  } );
};

const phetioAPIValidation = new phetioAPIValidation_PhetioAPIValidation();
tandemNamespace.register( 'phetioAPIValidation', phetioAPIValidation );
/* harmony default export */ var js_phetioAPIValidation = (phetioAPIValidation);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/tandem/js/PhetioObject.js
// Copyright 2017-2020, University of Colorado Boulder

/**
 * Base type that provides PhET-iO features. An instrumented PhetioObject is referred to on the wrapper side/design side
 * as a "PhET-iO element".  Note that sims may have hundreds or thousands of PhetioObjects, so performance and memory
 * considerations are important.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */













// constants
const PhetioObject_PHET_IO_ENABLED = js_Tandem.PHET_IO_ENABLED;
const IO_TYPE_VALIDATOR = { valueType: types_IOType };
const BOOLEAN_VALIDATOR = { valueType: 'boolean' };

// use "<br>" instead of newlines
const PHET_IO_DOCUMENTATION_VALIDATOR = { valueType: 'string', isValidValue: doc => doc.indexOf( '\n' ) === -1 };
const PHET_IO_EVENT_TYPE_VALIDATOR = { valueType: js_EventType };
const OBJECT_VALIDATOR = { valueType: [ Object, null ] };

const objectToPhetioID = phetioObject => phetioObject.tandem.phetioID;

// When an event is suppressed from the data stream, we keep track of it with this token.
const SKIPPING_MESSAGE = -1;

const DEFAULTS = {

  // Subtypes can use `Tandem.tandemRequired` to require a named tandem passed in
  tandem: js_Tandem.OPTIONAL,

  // Defines API methods, events and serialization
  phetioType: types_IOType.ObjectIO,

  // {string} Useful notes about an instrumented PhetioObject, shown in the PhET-iO Studio Wrapper. It's an html
  // string, so "<br>" tags are required instead of "\n" characters for proper rendering in Studio
  phetioDocumentation: '',

  // When true, includes the PhetioObject in the PhET-iO state (not automatically recursive, must be specified for
  // children explicitly)
  phetioState: true,

  // This option controls how PhET-iO wrappers can interface with this PhetioObject. Predominately this occurs via
  // public methods defined on this PhetioObject's phetioType, in which some method are not executable when this flag
  // is true. See `ObjectIO.methods` for further documentation, especially regarding `invocableForReadOnlyElements`.
  phetioReadOnly: false,

  // Category of event type, can be overridden in phetioStartEvent options
  phetioEventType: js_EventType.MODEL,

  // High frequency events such as mouse moves can be omitted from data stream, see ?phetioEmitHighFrequencyEvents
  // and Client.launchSim option
  phetioHighFrequency: false,

  // When true, emits events for data streams for playback, see handlePlaybackEvent.js
  phetioPlayback: false,

  // When true, Studio is allowed to create a control for this PhetioObject (if it knows how)
  phetioStudioControl: true,

  // When true, this is categorized as an important "featured" element in Studio.
  phetioFeatured: false,

  // {Object|null} optional - delivered with each event, if specified. phetioPlayback is appended here, if true.
  // Note: unlike other options, this option can be mutated downstream, and hence should be created newly for each instance.
  phetioEventMetadata: null,

  // {boolean} optional - indicates that an object may or may not have been created. Applies recursively automatically
  // and should only be set manually on the root dynamic element. Dynamic archetypes will have this overwritten to
  // false even if explicitly provided as true, as archetypes cannot be dynamic.
  phetioDynamicElement: false
};

class PhetioObject_PhetioObject {
  /**
   * @param {Object} [options]
   */
  constructor( options ) {

    // @public (read-only) {Tandem} - assigned in initializePhetioObject - see docs at DEFAULTS declaration
    this.tandem = DEFAULTS.tandem;

    // @private {boolean} - track whether the object has been initialized.  This is necessary because initialization
    // can happen in the constructor or in a subsequent call to initializePhetioObject (to support scenery Node)
    this.phetioObjectInitialized = false;

    // @public (read-only) {boolean} - has it been disposed?
    this.isDisposed = false;

    if ( options ) {
      this.initializePhetioObject( {}, options );
    }

    if ( assert ) {

      // Wrap the prototype dispose method with a check. NOTE: We will not catch devious cases where the dispose() is
      // overridden after the Node constructor (which may happen).
      const protoDispose = this.dispose;
      this.dispose = () => {
        assert && assert( !this.isDisposed, 'This PhetioObject has already been disposed, and cannot be disposed again' );
        protoDispose.call( this );
        assert && assert( this.isDisposed, 'PhetioObject.dispose() call is missing from an overridden dispose method' );
      };
    }
  }

  /**
   * Like SCENERY/Node, PhetioObject can be configured during construction or later with a mutate call.
   * Noop if provided config keys don't intersect with any key in DEFAULTS; baseOptions are ignored for this calculation.
   *
   * @param {Object} baseOptions
   * @param {Object} config
   * @protected
   */
  initializePhetioObject( baseOptions, config ) {
    assert && assert( config, 'initializePhetioObject must be called with config' );

    // call before we exit early to support logging unsupplied Tandems.
    config.tandem && js_Tandem.onMissingTandem( config.tandem );

    // Make sure that required tandems are supplied
    if ( js_Tandem.VALIDATION && config.tandem && config.tandem.required ) {
      assert && assert( config.tandem.supplied, 'required tandems must be supplied' );
    }

    // The presence of `tandem` indicates if this PhetioObject can be initialized. If not yet initialized, perhaps
    // it will be initialized later on, as in Node.mutate().
    if ( !( PhetioObject_PHET_IO_ENABLED && config.tandem && config.tandem.supplied ) ) {
      assert && !config.tandem && assert( !specifiesNonTandemPhetioObjectKey( config ), 'only specify metadata when providing a Tandem' );

      // In this case, the PhetioObject is not initialized, but still set tandem to maintain a consistent API for
      // creating the Tandem tree.
      if ( config.tandem ) {
        this.tandem = config.tandem;
      }
      return;
    }

    // assert this after the `specifiesPhetioObjectKey check to support something like:
    // `new Node( {tandem: tandem}).mutate({})`
    assert && assert( !this.phetioObjectInitialized, 'cannot initialize twice' );

    // Guard validation on assert to avoid calling a large number of no-ops when assertions are disabled, see https://github.com/phetsims/tandem/issues/200
    assert && js_validate( config.tandem, { valueType: js_Tandem } );

    config = js_merge( {}, DEFAULTS, baseOptions, config );

    // validate config before assigning to properties
    assert && js_validate( config.phetioType, IO_TYPE_VALIDATOR );
    assert && js_validate( config.phetioState, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioReadOnly, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioEventType, PHET_IO_EVENT_TYPE_VALIDATOR );
    assert && js_validate( config.phetioDocumentation, PHET_IO_DOCUMENTATION_VALIDATOR );
    assert && js_validate( config.phetioHighFrequency, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioPlayback, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioStudioControl, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioFeatured, BOOLEAN_VALIDATOR );
    assert && js_validate( config.phetioEventMetadata, OBJECT_VALIDATOR );
    assert && js_validate( config.phetioDynamicElement, BOOLEAN_VALIDATOR );

    assert && assert( this.linkedElements !== null, 'this means addLinkedElement was called before instrumentation of this PhetioObject' );

    // @public {boolean} optional - Indicates that an object is a archetype for a dynamic class. Settable only by
    // PhetioEngine and by classes that create dynamic elements when creating their archetype (like PhetioGroup) through
    // PhetioObject.markDynamicElementArchetype().
    // if true, items will be excluded from phetioState. This applies recursively automatically.
    this.phetioIsArchetype = false;

    // @public (phetioEngine) {Object|null}
    // Store the full baseline for usage in validation or for usage in studio.  Do this before applying overrides. The
    // baseline is created when a sim is run with assertions to assist in phetioAPIValidation.  However, even when
    // assertions are disabled, some wrappers such as studio need to generate the baseline anyway.
    // not all metadata are passed through via config, so store baseline for these additional properties
    this.phetioBaselineMetadata = ( js_phetioAPIValidation.enabled || phet.preloads.phetio.queryParameters.studio ) ?
                                  this.getMetadata( js_merge( {
                                    phetioIsArchetype: this.phetioIsArchetype
                                  }, config ) ) :
                                  null;

    // Dynamic elements should compare to their "archetypal" counterparts.  For example, this means that a Particle
    // in a PhetioGroup will take its overrides from the PhetioGroup archetype.
    const archetypalPhetioID = config.tandem.getArchetypalPhetioID();

    // Overrides are only defined for simulations, not for unit tests.  See https://github.com/phetsims/phet-io/issues/1461
    // Patch in the desired values from overrides, if any.
    if ( window.phet.preloads.phetio.phetioElementsOverrides ) {
      const overrides = window.phet.preloads.phetio.phetioElementsOverrides[ archetypalPhetioID ];
      if ( overrides ) {

        // No need to make a new object, since this "config" variable was created in the previous merge call above.
        config = js_merge( config, overrides );
      }
    }

    // @public (read-only) {Tandem} - see docs at DEFAULTS declaration
    this.tandem = config.tandem;

    // @public (read-only) {IOType} - see docs at DEFAULTS declaration
    this._phetioType = config.phetioType;

    // @public (read-only) {boolean} - see docs at DEFAULTS declaration
    this._phetioState = config.phetioState;

    // @public (read-only) {boolean} - see docs at DEFAULTS declaration
    this._phetioReadOnly = config.phetioReadOnly;

    // @public (read-only) {string} - see docs at DEFAULTS declaration
    this._phetioDocumentation = config.phetioDocumentation;

    // @private {EventType} - see docs at DEFAULTS declaration
    this._phetioEventType = config.phetioEventType;

    // @private {boolean} - see docs at DEFAULTS declaration
    this._phetioHighFrequency = config.phetioHighFrequency;

    // @private {boolean} - see docs at DEFAULTS declaration
    this._phetioPlayback = config.phetioPlayback;

    // @private {boolean} - see docs at DEFAULTS declaration
    this._phetioStudioControl = config.phetioStudioControl;

    // @public (PhetioEngine) {boolean} - see docs at DEFAULTS declaration - in order to recursively pass this value to
    // children, the setPhetioDynamicElement() function must be used instead of setting this attribute directly
    this._phetioDynamicElement = config.phetioDynamicElement;

    // @public (read-only) {boolean} - see docs at DEFAULTS declaration
    this._phetioFeatured = config.phetioFeatured;

    // @private {Object|null}
    this._phetioEventMetadata = config.phetioEventMetadata;

    // @private {string|null} - for phetioDynamicElements, the corresponding phetioID for the element in the archetype subtree
    this.phetioArchetypePhetioID = null;

    // @private {LinkedElement[]|null} - keep track of LinkedElements for disposal. Null out to support asserting on
    // edge error cases, see this.addLinkedElement()
    this.linkedElements = [];

    // @public (phet-io) set to true when this PhetioObject has been sent over to the parent.
    this.phetioNotifiedObjectCreated = false;

    // @private {Array.<number>} - tracks the indices of started messages so that dataStream can check that ends match starts.
    this.phetioMessageStack = [];

    // Make sure playback shows in the phetioEventMetadata
    if ( this._phetioPlayback ) {
      this._phetioEventMetadata = this._phetioEventMetadata || {};
      assert && assert( !this._phetioEventMetadata.hasOwnProperty( 'playback' ), 'phetioEventMetadata.playback should not already exist' );
      this._phetioEventMetadata.playback = true;
    }

    // Alert that this PhetioObject is ready for cross-frame communication (thus becoming a "PhET-iO element" on the wrapper side.
    this.tandem.addPhetioObject( this );
    this.phetioObjectInitialized = true;
  }

  // @public
  get phetioType() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioType only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioType;
  }

  // @public
  get phetioState() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioState only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioState;
  }

  // @public
  get phetioReadOnly() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioReadOnly only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioReadOnly;
  }

  // @public
  get phetioDocumentation() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioDocumentation only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioDocumentation;
  }

  // @private
  get phetioEventType() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioEventType only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioEventType;
  }

  // @private
  get phetioHighFrequency() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioHighFrequency only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioHighFrequency;
  }

  // @private
  get phetioPlayback() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioPlayback only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioPlayback;
  }

  // @private
  get phetioStudioControl() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioStudioControl only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioStudioControl;
  }

  // @public
  get phetioDynamicElement() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioDynamicElement only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioDynamicElement;
  }

  // @public
  get phetioFeatured() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioFeatured only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioFeatured;
  }

  // @private
  get phetioEventMetadata() {
    assert && assert( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented(), 'phetioEventMetadata only accessible for instrumented objects in PhET-iO brand.' );
    return this._phetioEventMetadata;
  }

  /**
   * Start an event for the nested PhET-iO data stream.
   *
   * @param {string} event - the name of the event
   * @param {Object} [options]
   * @public
   */
  phetioStartEvent( event, options ) {
    if ( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented() ) {

      // only one or the other can be provided
      assert && js_assertMutuallyExclusiveOptions( options, [ 'data' ], [ 'getData' ] );
      options = js_merge( {

        // {Object|null} - the data
        data: null,

        // {function():Object|null} - function that, when called get's the data.
        getData: null
      }, options );

      assert && assert( this.phetioObjectInitialized, 'phetioObject should be initialized' );
      assert && assert( typeof event === 'string' );
      assert && options.data && assert( typeof options.data === 'object' );
      assert && options.getData && assert( typeof options.getData === 'function' );
      assert && assert( arguments.length === 1 || arguments.length === 2, 'Prevent usage of incorrect signature' );

      // If you hit this, then it is likely related to https://github.com/phetsims/scenery/issues/1124 and we would like to know about it!
      assert && assert( phet.phetio.dataStream, 'trying to create an event before the data stream exists' );

      // Opt out of certain events if queryParameter override is provided. Even for a low frequency data stream, high
      // frequency events can still be emitted when they have a low frequency ancestor.
      const skipHighFrequencyEvent = this.phetioHighFrequency &&
                                     _.hasIn( window, 'phet.preloads.phetio.queryParameters' ) &&
                                     !window.phet.preloads.phetio.queryParameters.phetioEmitHighFrequencyEvents &&
                                     !phet.phetio.dataStream.isEmittingLowFrequencyEvent();

      if ( skipHighFrequencyEvent || this.phetioEventType === js_EventType.OPT_OUT ) {
        this.phetioMessageStack.push( SKIPPING_MESSAGE );
        return;
      }

      // Only get the args if we are actually going to send the event.
      const data = options.getData ? options.getData() : options.data;

      this.phetioMessageStack.push(
        phet.phetio.dataStream.start( this.phetioEventType, this.tandem.phetioID, this.phetioType, event, data, this.phetioEventMetadata, this.phetioHighFrequency )
      );

      // To support PhET-iO playback, any potential playback events downstream of this playback event must be marked as
      // non playback events. This is to prevent the PhET-iO playback engine from repeating those events. See
      // https://github.com/phetsims/phet-io/issues/1693
      this.phetioPlayback && phet.phetio.dataStream.pushNonPlaybackable();
    }
  }

  /**
   * End an event on the nested PhET-iO data stream. It this object was disposed or dataStream.start was not called,
   * this is a no-op.
   * @public
   */
  phetioEndEvent() {
    if ( PhetioObject_PHET_IO_ENABLED && this.isPhetioInstrumented() ) {

      assert && assert( this.phetioMessageStack.length > 0, 'Must have messages to pop' );
      const topMessageIndex = this.phetioMessageStack.pop();

      // The message was started as a high frequency event to be skipped, so the end is a no-op
      if ( topMessageIndex === SKIPPING_MESSAGE ) {
        return;
      }
      this.phetioPlayback && phet.phetio.dataStream.popNonPlaybackable();
      phet.phetio.dataStream.end( topMessageIndex );
    }
  }

  /**
   * Set any instrumented descendants of this PhetioObject to the same value as this.phetioDynamicElement.
   * @private
   */
  propagateDynamicFlagsToDescendants() {
    assert && assert( js_Tandem.PHET_IO_ENABLED, 'phet-io should be enabled' );
    assert && assert( phet.phetio && phet.phetio.phetioEngine, 'Dynamic elements cannot be created statically before phetioEngine exists.' );
    const phetioEngine = phet.phetio.phetioEngine;

    // in the same order as bufferedPhetioObjects
    const unlaunchedPhetioIDs = !js_Tandem.launched ? js_Tandem.bufferedPhetioObjects.map( objectToPhetioID ) : [];

    this.tandem.iterateDescendants( tandem => {
      const phetioID = tandem.phetioID;

      if ( phetioEngine.hasPhetioObject( phetioID ) || ( !js_Tandem.launched && unlaunchedPhetioIDs.includes( phetioID ) ) ) {
        assert && assert( this.isPhetioInstrumented() );
        const phetioObject = phetioEngine.hasPhetioObject( phetioID ) ? phetioEngine.getPhetioObject( phetioID ) :
                             js_Tandem.bufferedPhetioObjects[ unlaunchedPhetioIDs.indexOf( phetioID ) ];

        assert && assert( phetioObject, 'should have a phetioObject here' );

        // Order matters here! The phetioIsArchetype needs to be first to ensure that the setPhetioDynamicElement
        // setter can opt out for archetypes.
        phetioObject.phetioIsArchetype = this.phetioIsArchetype;
        phetioObject.setPhetioDynamicElement( this.phetioDynamicElement );

        if ( phetioObject.phetioBaselineMetadata ) {
          phetioObject.phetioBaselineMetadata.phetioIsArchetype = this.phetioIsArchetype;
        }
      }
    } );
  }

  /**
   * @param {boolean} phetioDynamicElement
   * @public (PhetioEngine)
   */
  setPhetioDynamicElement( phetioDynamicElement ) {
    assert && assert( !this.phetioNotifiedObjectCreated, 'should not change dynamic element flags after notifying this PhetioObject\'s creation.' );
    assert && assert( this.isPhetioInstrumented() );

    // All archetypes are static (non-dynamic)
    this._phetioDynamicElement = this.phetioIsArchetype ? false : phetioDynamicElement;

    // For dynamic elements, indicate the corresponding archetype element so that clients like Studio can leverage
    // the archetype metadata. Static elements don't have archetypes.
    this.phetioArchetypePhetioID = phetioDynamicElement ? this.tandem.getArchetypalPhetioID() : null;

    // Keep the baseline metadata in sync.
    if ( this.phetioBaselineMetadata ) {
      this.phetioBaselineMetadata.phetioDynamicElement = this.phetioDynamicElement;
    }
  }

  /**
   * Mark this PhetioObject as an archetype for dynamic elements.
   * @public
   */
  markDynamicElementArchetype() {
    assert && assert( !this.phetioNotifiedObjectCreated, 'should not change dynamic element flags after notifying this PhetioObject\'s creation.' );

    this.phetioIsArchetype = true;
    this.setPhetioDynamicElement( false ); // because archetypes aren't dynamic elements

    if ( this.phetioBaselineMetadata ) {
      this.phetioBaselineMetadata.phetioIsArchetype = this.phetioIsArchetype;
    }

    // recompute for children also, but only if phet-io is enabled
    js_Tandem.PHET_IO_ENABLED && this.propagateDynamicFlagsToDescendants();
  }

  /**
   * A PhetioObject will only be instrumented if the tandem that was passed in was "supplied". See Tandem.supplied
   * for more info.
   * @returns {boolean}
   * @public
   */
  isPhetioInstrumented() {
    return this.tandem && this.tandem.supplied;
  }

  /**
   * When an instrumented PhetioObject is linked with another instrumented PhetioObject, this creates a one-way
   * association which is rendered in Studio as a "symbolic" link or hyperlink. Many common code UI elements use this
   * automatically. To keep client sites simple, this has a graceful opt-out mechanism which makes this function a
   * no-op if either this PhetioObject or the target PhetioObject is not instrumented.
   * @param {PhetioObject} element - the target element. Must be instrumented for a LinkedElement to be created--
   *                               - otherwise it gracefully opts out
   * @param {Object} [options]
   * @public
   */
  addLinkedElement( element, options ) {
    if ( !this.isPhetioInstrumented() ) {

      // set this to null so that you can't addLinkedElement on an uninitialized PhetioObject and then instrument
      // it afterwards.
      this.linkedElements = null;
      return;
    }

    assert && assert( element instanceof PhetioObject_PhetioObject, 'element must be of type PhetioObject' );

    // In some cases, UI components need to be wired up to a private (internal) Property which should neither be
    // instrumented nor linked.
    if ( PhetioObject_PHET_IO_ENABLED && element.isPhetioInstrumented() ) {
      assert && assert( Array.isArray( this.linkedElements ), 'linkedElements should be an array' );
      this.linkedElements.push( new PhetioObject_LinkedElement( element, options ) );
    }
  }

  /**
   * Remove all linked elements linking to the provided PhetioObject. This will dispose all removed LinkedElements. This
   * will be graceful, and doesn't assume or assert that the provided PhetioObject has LinkedElement(s), it will just
   * remove them if they are there.
   * @param {PhetioObject} potentiallyLinkedElement
   * @public
   */
  removeLinkedElements( potentiallyLinkedElement ) {
    if ( this.isPhetioInstrumented() && this.linkedElements ) {
      assert && assert( potentiallyLinkedElement instanceof PhetioObject_PhetioObject );
      assert && assert( potentiallyLinkedElement.isPhetioInstrumented() );

      const toRemove = this.linkedElements.filter( linkedElement => linkedElement.element === potentiallyLinkedElement );
      toRemove.forEach( linkedElement => {
        linkedElement.dispose();
        js_arrayRemove( this.linkedElements, linkedElement );
      } );
    }
  }

  /**
   * Performs cleanup after the sim's construction has finished.
   *
   * @public
   */
  onSimulationConstructionCompleted() {

    // deletes the phetioBaselineMetadata, as it's no longer needed since validation is complete.
    this.phetioBaselineMetadata = null;
  }

  /**
   * Remove this phetioObject from PhET-iO. After disposal, this object is no longer interoperable. Also release any
   * other references created during its lifetime.
   * @public
   */
  dispose() {
    assert && assert( !this.isDisposed, 'PhetioObject can only be disposed once' );

    // In order to support the structured data stream, PhetioObjects must end the messages in the correct
    // sequence, without being interrupted by dispose() calls.  Therefore, we do not clear out any of the state
    // related to the endEvent.  Note this means it is acceptable (and expected) for endEvent() to be called on
    // disposed PhetioObjects.
    //
    // The phetioEvent stack should resolve by the next frame, so that's when we check it.
    assert && js_animationFrameTimer.runOnNextTick( () => {

      // Uninstrumented PhetioObjects don't have a phetioMessageStack attribute.
      assert && assert( !this.hasOwnProperty( 'phetioMessageStack' ) || this.phetioMessageStack.length === 0,
        'phetioMessageStack should be clear' );
    } );

    if ( this.phetioObjectInitialized ) {
      this.tandem.removePhetioObject( this );
    }

    // Dispose LinkedElements
    if ( this.linkedElements ) {
      this.linkedElements.forEach( linkedElement => linkedElement.dispose() );
      this.linkedElements.length = 0;
    }

    this.isDisposed = true;
  }

  /**
   * JSONifiable metadata that describes the nature of the PhetioObject.  We must be able to read this
   * for baseline (before object fully constructed we use object) and after fully constructed
   * which includes overrides.
   * @param {Object} [object] - used to get metadata keys, can be a PhetioObject, or an options object
   *                          (see usage initializePhetioObject). If not provided, will instead use the value of "this"
   * @returns {Object} - metadata plucked from the passed in parameter
   * @public
   */
  getMetadata( object ) {
    object = object || this;
    const metadata = {
      phetioTypeName: object.phetioType.typeName,
      phetioDocumentation: object.phetioDocumentation,
      phetioState: object.phetioState,
      phetioReadOnly: object.phetioReadOnly,
      phetioEventType: js_EventType.phetioType.toStateObject( object.phetioEventType ),
      phetioHighFrequency: object.phetioHighFrequency,
      phetioPlayback: object.phetioPlayback,
      phetioStudioControl: object.phetioStudioControl,
      phetioDynamicElement: object.phetioDynamicElement,
      phetioIsArchetype: object.phetioIsArchetype,
      phetioFeatured: object.phetioFeatured
    };
    if ( object.phetioArchetypePhetioID ) {
      metadata.phetioArchetypePhetioID = object.phetioArchetypePhetioID;
    }
    return metadata;
  }

}


PhetioObject_PhetioObject.DEFAULT_OPTIONS = DEFAULTS; // the default options for the phet-io object

// THe keys that constitute the publicly available PHET-iO metadata for the PhetioObject.
PhetioObject_PhetioObject.METADATA_KEYS = [
  'phetioTypeName',
  'phetioDocumentation',
  'phetioState',
  'phetioReadOnly',
  'phetioEventType',
  'phetioHighFrequency',
  'phetioPlayback',
  'phetioStudioControl',
  'phetioDynamicElement',
  'phetioIsArchetype',
  'phetioFeatured',
  'phetioArchetypePhetioID'
];

/**
 * Determine if any of the options keys are intended for PhetioObject. Semantically equivalent to
 * _.intersection( _.keys( options ), _.keys( DEFAULTS) ).length>0 but implemented imperatively to avoid memory or
 * performance issues. Also handles options.tandem differently.
 * @param {Object} [options]
 * @returns {boolean}
 */
const specifiesNonTandemPhetioObjectKey = options => {
  for ( const key in options ) {
    if ( key !== 'tandem' && options.hasOwnProperty( key ) && DEFAULTS.hasOwnProperty( key ) ) {
      return true;
    }
  }
  return false;
};

// Since PhetioObject is extended with inherit (e.g., SCENERY/Node), this cannot be an ES6 class
/**
 * Internal class to avoid cyclic dependencies.
 * @private
 */
class PhetioObject_LinkedElement extends PhetioObject_PhetioObject {

  /**
   * @param {PhetioObject} coreElement
   * @param {Object} [options]
   */
  constructor( coreElement, options ) {
    assert && assert( !!coreElement, 'coreElement should be defined' );
    assert && assert( coreElement instanceof PhetioObject_PhetioObject, 'coreElement should be PhetioObject' );
    assert && assert( coreElement.tandem, 'coreElement should have a tandem' );

    options = js_merge( {
      phetioType: js_LinkedElementIO
    }, options );

    // References cannot be changed by PhET-iO
    assert && assert( !options.hasOwnProperty( 'phetioReadOnly' ), 'phetioReadOnly set by LinkedElement' );
    options.phetioReadOnly = true;

    // By default, this linked element's baseline value is the overridden value of the coreElement. This allows
    // the them to be in sync by default, but also allows the linked element to be overridden in studio.
    assert && assert( !options.hasOwnProperty( 'phetioFeatured' ), 'phetioFeatured set by LinkedElement' );
    options.phetioFeatured = coreElement.phetioFeatured;

    super( options );

    // @public (read-only)
    this.element = coreElement;
  }

  /**
   * LinkedElements listen to their core elements for phetioFeatured, so to avoid a dependency on overrides metadata
   * (when the core element's phetioFeatured is specified in the overrides file), ignore phetioFeatured for LinkedElements.
   * @override
   * @param {Object} object - used to get metadata keys, can be a PhetioObject, or an options object
   *                          (see usage initializePhetioObject)
   * @returns {Object} - metadata plucked from the passed in parameter
   * @public
   */
  getMetadata( object ) {
    const phetioObjectMetadata = super.getMetadata( object );
    delete phetioObjectMetadata.phetioFeatured;
    return phetioObjectMetadata;
  }
}

tandemNamespace.register( 'PhetioObject', PhetioObject_PhetioObject );
/* harmony default export */ var js_PhetioObject = (PhetioObject_PhetioObject);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/Action.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * An action that can be executed and sent to the PhET-iO data stream, and optionally recorded for playback. This type
 * will also validate the argument types passed to the action function.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */











// constants
const Action_VALIDATE_OPTIONS_FALSE = { validateValidator: false };

// Simulations have thousands of Emitters, so we re-use objects where possible.
const EMPTY_ARRAY = [];
assert && Object.freeze( EMPTY_ARRAY );

// allowed keys to options.parameters
const PARAMETER_KEYS = [
  'name', // {string} - required for phet-io instrumented Actions
  'phetioType', // {IOType} - required for phet-io instrumented Actions
  'phetioDocumentation', // {string} - optional, additional documentation for this specific parameter

  // {boolean=true} - specify this to keep the parameter private to the phet-io api. To support emitting and executing over
  // the phet-io api, phetioPrivate parameters must not ever be before a public one. For example
  // `emit1( public1, private1, public2)` is not allowed. Instead it must be ordered like `emit( public1, public2, private1 )`
  'phetioPrivate'
].concat( js_ValidatorDef.VALIDATOR_KEYS );

// helper closures
const paramToPhetioType = param => param.phetioType;
const paramToName = param => param.name;

class Action_Action extends js_PhetioObject {

  /**
   * @param {function} action - the function that is called when this Action occurs
   * @param {Object} [options]
   */
  constructor( action, options ) {
    options = js_merge( {

      // {Object[]} - see PARAMETER_KEYS for a list of legal keys, their types, and documentation
      parameters: EMPTY_ARRAY,

      // phet-io - see PhetioObject.js for doc
      tandem: js_Tandem.OPTIONAL,

      // {function(IOType[]):IOType} - The non parameterized IOType. Override this to create a subtype of ActionIO as
      // the phetioType instead of a parameterized ActionIO Type.
      phetioOuterType: Action_Action.ActionIO,
      phetioState: false,
      phetioPlayback: js_PhetioObject.DEFAULT_OPTIONS.phetioPlayback,
      phetioEventMetadata: js_PhetioObject.DEFAULT_OPTIONS.phetioEventMetadata,
      phetioDocumentation: 'A function that executes.'
    }, options );

    assert && Action_Action.validateParameters( options.parameters, options.tandem.supplied );
    assert && assert( typeof action === 'function', 'action should be a function' );
    assert && assert( options.phetioType === undefined,
      'Action sets its own phetioType. Instead provide parameter phetioTypes through `options.parameters`' );

    // {Object[]} - list of parameters, see options.parameters. Filter out phetioPrivate parameters, all `phetioPrivate`
    // parameters will not have a `phetioType`, see `validateParameters`.
    const phetioPublicParameters = options.parameters.filter( paramToPhetioType );

    options.phetioType = options.phetioOuterType( phetioPublicParameters.map( paramToPhetioType ) );

    // phetioPlayback events need to know the order the arguments occur in order to call EmitterIO.emit()
    // Indicate whether the event is for playback, but leave this "sparse"--only indicate when this happens to be true
    if ( options.phetioPlayback ) {
      options.phetioEventMetadata = options.phetioEventMetadata || {};

      assert && assert( !options.phetioEventMetadata.hasOwnProperty( 'dataKeys' ),
        'dataKeys should be supplied by Action, not elsewhere' );

      options.phetioEventMetadata.dataKeys = options.parameters.map( paramToName );
    }
    options.phetioDocumentation = Action_Action.getPhetioDocumentation( options.phetioDocumentation, phetioPublicParameters );

    super( options );

    // @public (only for testing) - Note: one test indicates stripping this out via assert && in builds may save around 300kb heap
    this._parameters = options.parameters;

    // @private {function}
    this._action = action;

    // @private - only needed for dispose, see options for doc
    this._phetioOuterType = options.phetioOuterType;
  }

  /**
   * @param {object} parameters
   * @param {boolean} tandemSupplied - proxy for whether the PhetioObject is instrumented.  We cannot call
   *                                 - PhetioObject.isPhetioInstrumented() until after the supercall, so we use this beforehand.
   * @private
   */
  static validateParameters( parameters, tandemSupplied ) {

    // validate the parameters object
    js_validate( parameters, { valueType: Array } );

    // Action only supports phetioPrivate parameters at the end of the emit call, so once we hit the first phetioPrivate
    // parameter, then assert that the rest of them afterwards are as well.
    let reachedPhetioPrivate = false;

    // we must iterate from the first parameter to the last parameter to support phetioPrivate
    for ( let i = 0; i < parameters.length; i++ ) {
      const parameter = parameters[ i ]; // metadata about a single parameter

      assert && assert( Object.getPrototypeOf( parameter ) === Object.prototype,
        'Extra prototype on parameter object is a code smell' );

      reachedPhetioPrivate = reachedPhetioPrivate || parameter.phetioPrivate;
      assert && reachedPhetioPrivate && assert( parameter.phetioPrivate,
        'after first phetioPrivate parameter, all subsequent parameters must be phetioPrivate' );

      assert && tandemSupplied && js_Tandem.VALIDATION && assert( parameter.phetioType || parameter.phetioPrivate,
        'instrumented Emitters must include phetioType for each parameter or be marked as `phetioPrivate`.' );
      assert && parameter.phetioType && assert( parameter.name,
        '`name` is a required parameter for phet-io instrumented parameters.' );
      assert && js_assertMutuallyExclusiveOptions( parameter, [ 'phetioPrivate' ], [
        'name', 'phetioType', 'phetioDocumentation'
      ] );

      assert && assert( _.intersection( Object.keys( parameter ), js_ValidatorDef.VALIDATOR_KEYS ).length > 0,
        `validator must be specified for parameter ${i}` );

      for ( const key in parameter ) {
        assert && assert( PARAMETER_KEYS.includes( key ), 'unrecognized parameter key: ' + key );
      }

      // Changing after construction indicates a logic error.
      assert && Object.freeze( parameters[ i ] );

      // validate the options passed in to validate each Action argument
      js_ValidatorDef.validateValidator( parameter );
    }

    // Changing after construction indicates a logic error.
    assert && Object.freeze( parameters );
  }

  /**
   * Gets the data that will be emitted to the PhET-iO data stream, for an instrumented simulation.
   * @returns {Object} - the data, keys dependent on parameter metadata
   * @private
   */
  getPhetioData() {

    assert && assert( js_Tandem.PHET_IO_ENABLED, 'should only get phet-io data in phet-io brand' );

    // null if there are no arguments. dataStream.js omits null values for data
    let data = null;
    if ( this._parameters.length > 0 ) {

      // Enumerate named argsObject for the data stream.
      data = {};
      for ( let i = 0; i < this._parameters.length; i++ ) {
        const element = this._parameters[ i ];
        if ( !element.phetioPrivate ) {
          data[ element.name ] = element.phetioType.toStateObject( arguments[ i ] );
        }
      }
    }
    return data;
  }

  /**
   * Get the phetioDocumentation compiled from all the parameters
   * @param {boolean} currentPhetioDocumentation
   * @param {Object} parameters - see options.parameters
   * @private
   * @returns {string}
   */
  static getPhetioDocumentation( currentPhetioDocumentation, parameters ) {
    const paramToDocString = param => {

      const docText = param.phetioDocumentation ? ` - ${param.phetioDocumentation}` : '';

      return `<li>${param.name}: ${param.phetioType.typeName}${docText}</li>`;
    };

    return currentPhetioDocumentation + ( parameters.length === 0 ? '<br>No parameters.' : '<br>The parameters are:<br/>' +
           '<ol>' + parameters.map( paramToDocString ).join( '<br/>' ) + '</ol>' );
  }

  /**
   * Invokes the action.
   * @params - expected parameters are based on options.parameters, see constructor
   * @public
   */
  execute() {
    if ( assert ) {
      assert( arguments.length === this._parameters.length,
        `Emitted unexpected number of args. Expected: ${this._parameters.length} and received ${arguments.length}`
      );
      for ( let i = 0; i < this._parameters.length; i++ ) {
        const parameter = this._parameters[ i ];
        js_validate( arguments[ i ], parameter, Action_VALIDATE_OPTIONS_FALSE );

        // valueType overrides the phetioType validator so we don't use that one if there is a valueType
        if ( parameter.phetioType && !this._parameters.valueType ) {
          js_validate( arguments[ i ], parameter.phetioType.validator, Action_VALIDATE_OPTIONS_FALSE );
        }
      }
    }

    // handle phet-io data stream for the emitted event
    this.phetioStartEvent( 'emitted', {
      getData: () => this.getPhetioData.apply( this, arguments ) // put this in a closure so that it is only called in phet-io brand
    } );

    this._action.apply( null, arguments );

    this.phetioEndEvent();
  }
}

const paramToTypeName = param => param.typeName;

// {Map.<string, IOType>} - Cache each parameterized IOType so that
// it is only created once.
const Action_cache = new Map();

Action_Action.ActionIO = parameterTypes => {
  const key = parameterTypes.map( paramToTypeName ).join( ',' );
  if ( !Action_cache.has( key ) ) {
    Action_cache.set( key, new types_IOType( `ActionIO<${parameterTypes.map( paramToTypeName ).join( ', ' )}>`, {
      valueType: Action_Action,
      documentation: 'Executes when an event occurs',
      events: [ 'emitted' ],
      parameterTypes: parameterTypes,
      methods: {
        execute: {
          returnType: types_VoidIO,
          parameterTypes: parameterTypes,

          // Match `Action.execute`'s dynamic number of arguments
          implementation: function() {
            this.execute.apply( this, arguments );
          },
          documentation: 'Executes the function the Action is wrapping.',
          invocableForReadOnlyElements: false
        }
      }
    } ) );
  }
  return Action_cache.get( key );
};

axon.register( 'Action', Action_Action );
/* harmony default export */ var js_Action = (Action_Action);
// CONCATENATED MODULE: C:/Users/Michael/PhET/git/axon/js/Emitter.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * Event & listener abstraction for a single "event" type. The type provides extra functionality beyond just notifying
 * listeners. It adds PhET-iO instrumentation capabilities as well as validation. For the lightest-weight, fastest
 * solution with the smallest memory footprint, see `TinyEmitter`.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 */









class Emitter_Emitter extends js_Action {

  /**
   * @param {Object} [options]
   */
  constructor( options ) {

    options = js_merge( {
      phetioOuterType: Emitter_Emitter.EmitterIO
    }, options );

    super( function() {
      assert && assert( self.tinyEmitter instanceof js_TinyEmitter,
        'Emitter should not emit until after its constructor has completed' );

      self.tinyEmitter.emit.apply( self.tinyEmitter, arguments );
    }, options );

    const self = this;

    // @private - provide Emitter functionality via composition
    this.tinyEmitter = new js_TinyEmitter();
  }

  /**
   * Emitter instances should not be calling Action.execute, instead see Emitter.emit().
   * See the second half of https://github.com/phetsims/axon/issues/243 for discussion.
   * @override
   * @public
   */
  execute() {
    assert && assert( false, 'This should not be called, use Emitter.emit() instead.' );
  }

  /**
   * Emit to notify listeners; implemented by executing the action of the parent class.
   * @public
   * @params {*}
   */
  emit() {
    super.execute.apply( this, arguments );
  }

  /**
   * Disposes an Emitter. All listeners are removed.
   * @public
   * @override
   */
  dispose() {
    this.tinyEmitter.dispose();
    super.dispose();
  }

  /**
   * Adds a listener which will be called during emit.
   * @param {function} listener
   * @public
   */
  addListener( listener ) {
    this.tinyEmitter.addListener( listener );
  }

  /**
   * Removes a listener
   * @param {function} listener
   * @public
   */
  removeListener( listener ) {
    this.tinyEmitter.removeListener( listener );
  }

  /**
   * Removes all the listeners
   * @public
   */
  removeAllListeners() {
    this.tinyEmitter.removeAllListeners();
  }

  /**
   * Checks whether a listener is registered with this Emitter
   * @param {function} listener
   * @returns {boolean}
   * @public
   */
  hasListener( listener ) {
    return this.tinyEmitter.hasListener( listener );
  }

  /**
   * Returns true if there are any listeners.
   * @returns {boolean}
   * @public
   */
  hasListeners() {
    return this.tinyEmitter.hasListeners();
  }

  /**
   * Returns the number of listeners.
   * @returns {number}
   * @public
   */
  getListenerCount() {
    return this.tinyEmitter.getListenerCount();
  }
}


const Emitter_paramToTypeName = param => param.typeName;

// {Map.<string, IOType>} - Cache each parameterized IOType so that
// it is only created once.
const Emitter_cache = new Map();

/**
 * IO Type for Emitter.
 *
 * Providing validators to instrumented Emitters:
 * Instrumented Emitters should have their `validators` for each argument passed via EmitterIO (the phetioType).
 * To provide validators, there are two methods. First, by default each IOType has its own
 * validator that will be used. So specifying an argument object like `{ type: NumberIO }` will automatically use
 * `NumberIO.validator` as the validator. This can be overridden with the `validator` key (second option), like
 * { type: NumberIO, validator: { isValidValue: v=> typeof v === 'number' &&  v < 5 } }`
 * NOTE: currently the implementation is either/or, if a validator is provided via the `validator` key, the validator
 * from the `type` will be ignored.
 * see https://github.com/phetsims/axon/issues/204 for more details.
 *
 * @author Sam Reid (PhET Interactive Simulations)
 * @author Michael Kauzmann (PhET Interactive Simulations)
 * @author Andrew Adare (PhET Interactive Simulations)
 */
Emitter_Emitter.EmitterIO = parameterTypes => {

  const key = parameterTypes.map( Emitter_paramToTypeName ).join( ',' );

  if ( !Emitter_cache.has( key ) ) {
    Emitter_cache.set( key, new types_IOType( `EmitterIO<${parameterTypes.map( Emitter_paramToTypeName ).join( ', ' )}>`, {
      valueType: Emitter_Emitter,
      supertype: js_Action.ActionIO( parameterTypes ),
      documentation: 'Emits when an event occurs and calls added listeners.',
      parameterTypes: parameterTypes,
      methods: {
        addListener: {
          returnType: types_VoidIO,
          parameterTypes: [ types_FunctionIO( types_VoidIO, parameterTypes ) ],
          implementation: function( listener ) {
            this.addListener( listener );
          },
          documentation: 'Adds a listener which will be called when the emitter emits.'
        },
        removeListener: {
          returnType: types_VoidIO,
          parameterTypes: [ types_FunctionIO( types_VoidIO, parameterTypes ) ],
          implementation: function( listener ) {
            this.removeListener( listener );
          },
          documentation: 'Remove a listener.'
        },
        emit: {
          returnType: types_VoidIO,
          parameterTypes: parameterTypes,

          // Match `Emitter.emit`'s dynamic number of arguments
          implementation: function() {
            this.emit.apply( this, arguments );
          },
          documentation: 'Emits a single event to all listeners.',
          invocableForReadOnlyElements: false
        }
      }
    } ) );
  }
  return Emitter_cache.get( key );
};

axon.register( 'Emitter', Emitter_Emitter );
/* harmony default export */ var js_Emitter = (Emitter_Emitter);
// CONCATENATED MODULE: ./TemplateVariable.js
// Copyright 2019-2020, University of Colorado Boulder

/**
 * A data structure to hold all info for a single templated variable. This includes the select box with options and ui
 * to update it, as well as name and index in the input sentence.
 */
class TemplateVariable {

  /**
   * @param {string} name
   * @param {number} index
   */
  constructor( name, index ) {

    // @public (read-only)
    this.name = name;
    this.index = index;

    // @private {string[]}
    this.options = [];

    // @public (read-only)
    this.select = document.createElement( 'select' );

    // TODO: rename this.ui to something else
    // @public (read-only)
    this.ui = document.createElement( 'div' );

    // @private
    this.optionAddingArea = document.createElement( 'textarea' );
    this.wireUpVariableUI();
  }

  /**
   * Create the UI that will be used to set options for this variable. Some elements are created in the constructor
   * because they are used by other places. HTML that is otherwise used for display is created, populated, and wired up
   * by this function.
   * @private
   */
  wireUpVariableUI() {
    this.optionAddingArea.addEventListener( 'input', () => {
      this.options = [];
      const inputOptions = this.optionAddingArea.value.split( '\n' );
      this.optionAddingArea.rows = Math.max( this.optionAddingArea.rows, inputOptions.length );
      this.setOptions( inputOptions.filter( option => option !== '' ) );
    } );

    this.optionAddingArea.id = 'optionAddingArea-${name}';
    const uiLabel = document.createElement( 'label' );
    uiLabel.innerHTML = `<strong>${this.name}:</strong>`;
    uiLabel.setAttribute( 'for', this.optionAddingArea.id );
    this.ui.appendChild( uiLabel );
    this.ui.appendChild( document.createElement( 'br' ) );
    this.ui.appendChild( this.optionAddingArea );
    this.ui.appendChild( document.createElement( 'br' ) );
  }

  /**
   * serialize into json
   * @public
   * @returns {Object}
   */
  serialize() {
    return {
      name: this.name,
      index: this.index,
      options: this.options,
      selectedOption: this.select.value
    };
  }

  /**
   * @public
   * @param {Object} serializedTemplateVar - see TemplateVariable.prototype.serialize()
   * @returns {TemplateVariable}
   */
  static deserialize( serializedTemplateVar ) {
    const variable = new TemplateVariable( serializedTemplateVar.name, serializedTemplateVar.index );
    variable.setOptions( serializedTemplateVar.options );
    variable.optionAddingArea.value = variable.options.join( '\n' );
    variable.updateSelectBox();
    variable.select.value = serializedTemplateVar.selectedOption;
    return variable;
  }

  /**
   * @private
   * Update the select box with current options
   */
  updateSelectBox() {
    this.select.innerHTML = '';
    this.options.forEach( optionName => {
      const option = document.createElement( 'option' );
      option.innerText = optionName;
      this.select.appendChild( option );
    } );
  }

  /**
   * Set all the options and repopulate the select box
   * @private
   * @param {string[]} optionName
   */
  setOptions( options ) {
    this.options = options.slice();
    this.updateSelectBox();
  }
}

/* harmony default export */ var TemplateVariable_0 = (TemplateVariable);
// CONCATENATED MODULE: ./PhraseBuilder.js
// Copyright 2019-2020, University of Colorado Boulder





// constants
const TEMPLATE_VAR_REGEX = /\{\{(\w*)}\}/;
const SAVING_KEY_PREFIX = 'phrase-builder-';
const AUTO = 'auto';

function appendBR( element ) {
  element.appendChild( document.createElement( 'br' ) );
}

/**
 * This type is responsible for creating a sentence that transforms template vars into select boxes with specific
 * options based on that dynamic variable. It also makes sure that variables are not discarded between changes in the
 * input.
 *
 * Constraints: each template var string must be unique
 */
class PhraseBuilder_PhraseBuilder {

  /**
   * @param {HTMLElement} container - the container for the phrase builder html
   * @param {Object} [options]
   */
  constructor( container, options ) {

    options = js_merge( {
      withParameterNaming: false // basically a flag to opt into this being a part of the ID design tool.
    }, options );

    this.vars = []; // {TemplateVariable[]}
    this.input = document.createElement( 'textarea' );
    this.varUI = document.createElement( 'div' );
    this.outputSentence = document.createElement( 'div' );
    this.withParameterNaming = options.withParameterNaming;
    this.name = null;
    this.populateContainerHTML( container );

    this.input.addEventListener( 'input', () => {
      this.onInput( this.input.value );
    } );

    // autosave on each new input change from the input sentence, variable UIs, or output sentence (select box change)
    container.addEventListener( 'input', () => {
      this.save( AUTO );
    } );

    // @public
    this.descriptionSentenceCreatedEmitter = new js_Emitter( {
      parameters: [ { valueType: Object } ]
    } );
  }

  /**
   * Responsible for creating the expected HTML for the phrase builder. Elements created in the constructor are used,
   * elsewhere, but their HTML presence is edited and created here.
   * @param {HTMLElement} container
   * @private
   */
  populateContainerHTML( container ) {

    if ( this.withParameterNaming ) {

      const nameInput = document.createElement( 'input' );
      nameInput.type = 'text';
      nameInput.id = 'description-name';
      nameInput.addEventListener( 'input', () => {
        this.name = nameInput.value;
      } );
      const nameLabel = document.createElement( 'label' );
      nameLabel.innerText = 'Description Name:';
      nameLabel.setAttribute( 'for', 'description-name' );
      container.appendChild( nameLabel );
      container.appendChild( nameInput );
      container.appendChild( document.createElement( 'br' ) );
    }

    const inputLabel = document.createElement( 'label' );
    inputLabel.innerHTML = '<strong>Input raw sentence with template variables:</strong>';
    inputLabel.setAttribute( 'for', 'sentenceInput' );
    this.input.rows = 10;
    this.input.cols = 60;
    this.input.id = 'sentenceInput';
    inputLabel.setAttribute( 'for', this.input.id );
    container.appendChild( inputLabel );
    appendBR( container );
    container.appendChild( this.input );

    appendBR( container );
    appendBR( container );

    const optionAddingDescriptionP = document.createElement( 'p' );
    optionAddingDescriptionP.innerText = 'As template variables are added above, text areas will be added below. For ' +
                                         'each, specify options for each variable separated by a new line.';
    container.appendChild( optionAddingDescriptionP );
    container.appendChild( this.varUI );

    appendBR( container );
    appendBR( container );

    const outputLabel = document.createElement( 'label' );
    outputLabel.innerHTML = '<strong>Output sentence:</strong>';
    this.outputSentence.id = 'sentenceOutput';
    outputLabel.setAttribute( 'for', this.outputSentence.id );
    container.appendChild( outputLabel );
    container.appendChild( this.outputSentence );

    if ( this.withParameterNaming ) {

      const save = document.createElement( 'button' );
      save.id = 'description-save';
      save.innerText = 'Create Description';
      save.addEventListener( 'click', () => {
        this.descriptionSentenceCreatedEmitter.emit( this.serialize() );
      } );
      container.appendChild( save );
    }
  }

  /**
   * Update the output container
   * @param string
   * @private
   */
  updateOutputPhrase( string ) {
    this.outputSentence.innerHTML = '';

    let currentIndex = 0;
    this.vars.forEach( templateVar => {
      const toAppend = string.slice( currentIndex, templateVar.index );
      appendSpanText( this.outputSentence, toAppend );
      this.outputSentence.appendChild( templateVar.select );
      currentIndex = templateVar.index + templateVar.name.length + 4; // 4 for the curly braces `{{}}`
    } );

    appendSpanText( this.outputSentence, string.slice( currentIndex ) );
  }

  /**
   * update the ui controlling options for each variable
   * @private
   */
  updateVarUI() {
    this.varUI.innerHTML = '';
    this.vars.forEach( templateVar => {
      this.varUI.appendChild( templateVar.ui );
    } );
  }

  /**
   * On input change in the input sentence
   * @param string
   * @private
   */
  onInput( string ) {
    const newVars = [];
    findAll( TEMPLATE_VAR_REGEX, string ).forEach( variableOutput => {
      // For `ohhi{{fdsa}}` output looks like `["{{fdsa}}", "fdsa", index: 4, groups: undefined]`

      const variableName = variableOutput[ 1 ];

      let alreadyExists = false;

      // TODO: use lodash instead?
      this.vars.forEach( templateVar => {
        if ( templateVar.name === variableName ) {
          alreadyExists = true;
          newVars.push( templateVar );
        }
      } );

      // if it didn't already exist, then let's create a new one
      !alreadyExists && newVars.push( new TemplateVariable_0( variableName, variableOutput.index ) );
    } );
    this.vars = newVars;
    this.updateUI( string );

    // autosave on each new input from the input sentence
    this.save( AUTO );
  }

  /**
   * Update UI elements of the phrase builder
   * @param {string} inputValue - the value of the input text box
   * @private
   */
  updateUI( inputValue ) {
    this.updateVarUI();
    this.updateOutputPhrase( inputValue );
  }

  /**
   * @private
   * @returns {Object}
   */
  serialize() {
    return {
      input: this.input.value,
      variables: this.vars.map( variable => variable.serialize() ),
      name: this.name
    };
  }

  /**
   * @public
   * Autoload whatever was most recently autosaved
   */
  autoload() {
    this.load( AUTO );
  }

  /**
   * @public
   * @param {string} name - the name of the phrase builder instance to load
   */
  load( name ) {
    const storedPhraseBuilder = window.localStorage.getItem( `${SAVING_KEY_PREFIX}${name}` );
    if ( storedPhraseBuilder ) {
      const serializedPhraseBuilder = JSON.parse( storedPhraseBuilder );
      this.input.value = serializedPhraseBuilder.input;
      this.vars = serializedPhraseBuilder.variables.map( variable => TemplateVariable_0.deserialize( variable ) );
      this.updateUI( this.input.value );
    }
  }

  /**
   * Save this phrase builder instance under the name provided
   * @param {string} name
   * @public
   */
  save( name ) {
    window.localStorage.setItem( `${SAVING_KEY_PREFIX}${name}`, JSON.stringify( this.serialize() ) );
  }


  /**
   * Creator method
   * @param {HTMLElement} input - the input element to monitor for sentence changes
   * @param {HTMLElement} varDiv - container for the variable uis
   * @param {HTMLElement} output - container for the output sentence
   * @returns {PhraseBuilder}
   * @public
   */
  static create( input, varDiv, output ) {
    return new PhraseBuilder_PhraseBuilder( input, varDiv, output );
  }
}

/**
 * Append a string as a span to a div
 * @param {HTMLElement} div
 * @param {string} string
 */
function appendSpanText( div, string ) {
  const p = document.createElement( 'span' );
  p.innerText = string;
  div.appendChild( p );
}

/**
 * Copied from https://stackoverflow.com/questions/6323417/how-do-i-retrieve-all-matches-for-a-regular-expression-in-javascript
 * @param {regex}regexPattern
 * @param {string} sourceString
 * @returns {Array.<Object>} - all the matches, each is an output of RegExp.exec (with index property too)
 */
function findAll( regexPattern, sourceString ) {
  const output = [];
  let match;

  // make sure the pattern has the global flag
  const regexPatternWithGlobal = RegExp( regexPattern, 'g' );
  while ( match = regexPatternWithGlobal.exec( sourceString ) ) { // eslint-disable-line no-cond-assign

    // get rid of the string copy
    delete match.input;

    // store the match data
    output.push( match );
  }
  return output;
}

/* harmony default export */ var PhraseBuilder_0 = (PhraseBuilder_PhraseBuilder);
// CONCATENATED MODULE: ./main.js
// Copyright 2021, University of Colorado Boulder



const phraseBuilder = PhraseBuilder_0.create(
  document.getElementById( 'container' )
);

window.addEventListener( 'load', () => {
  phraseBuilder.autoload();
} );
const descriptionNameInput = document.getElementById( 'descriptionName' );
document.getElementById( 'save' ).addEventListener( 'click', () => {
  phraseBuilder.save( descriptionNameInput.value );
} );
document.getElementById( 'load' ).addEventListener( 'click', () => {
  phraseBuilder.load( descriptionNameInput.value );
} );

/***/ })
/******/ ]);</script>
</html>